* PHP?

웹 브라우저의 주소창에 index.html 파일을 저장했다면 요청을 받은 서버 컴퓨터에 설치돼 있는 웹 서버라는 소프트웨어가 주소를 보고 확장자가 .html인 것을 보면 직접 자신이 처리할 수 있다는 것을 알기 때문에 서버 컴퓨터의 하드디스크나 SSD에 있는 htdocs 디렉터리에서 index.html파일을 읽어서 바로 웹 브라우저에게 전송하면 웹 브라우저는 그 코드의 내용을 해석해서 화면에 표시하는 것으로 이 과정이 끝나게 된다.

이번에는 사용자가 웹 브라우저에서 주소창에 index.php, 즉 확장자로 .html이 아닌 .php를 쓰면 웹 서버는 확장자 .php인 파일은 자신의 소관이 아님을 안다.
그러면 웹 서버는 확장자가 .php파일을 처리할 수 있는 소프트웨어가 php라는 프로그램임을 알고 있기 때문에 이 파일의 처리를 php라는 프로그램에게 위임한다.
그러면 php라는 프로그램은 htdocs 디렉터리 안에 있는 index.php파일을 열어서 거기에 적힌 php라는 컴퓨터 언어의 문법에 따라 해석해서 최종적으로 HTML 파일을 만들어 낸다.
그러면 그렇게 만들어진 HTML을 웹 서버가 웹 브라우저에게 전송하는 것을 통해 이 과정이 끝나게 된다.

HTML 파일은 사용자가 적어준 대로만 출력하기 때문에 정적이고, PHP파일은 사용자가 적어준 내용을 동적으로 표현할 수 있다.

* PHP의 데이터 타입

PHP 같은 프로그래밍 언어를 배울 때 굉장히 중요한 것은, 프로그래밍 언어를 사용하는 이유  중 하나는 데이터를 어떠한 의도에 따라 처리하는 것이라는 점이다.
그렇기  때문에 프로그래밍을 배울 때 그 컴퓨터 언어가 어떤 형식들을 제공하는지 알아가는 과정과 언어에서 제공하는 데이터 타입별 처리 방법을 알아가는 과정이 아주 중요한 트랙 중 하나다.

지금부터 살펴볼 것은 이 PHP라는 언어가 지원하는 데이터 타입 가운데 여러분이 가장 보편적으로 많이 사용하고 이미 익숙한 데이터 타입인 숫자와 문자열이다.
먼저 php라는 언어는 어떤 데이터 타입을 지원하는지 검색을 통해 알아보자.

1. 숫자를 표현하는 데이터 타입

PHP에서 숫자를 표현하는 데는 크게 두 가지 방법이 있는데 하나는 integer고 또 하나는 float이다.

integer = 정수ㅜ

float = 부동소수점

부동소수점은 소수점이 있는 실수라 생각하면 된다
여기서는 가장 많이 사용되는 정수 (integer) 먼저 보겠다.

자연에서 만들어진 숫자는 무엇인가?
자연수이다.
그 자연수와 인류의 빛나는 업적, 인도에서 만들어진 0이라는 숫자와 음수를 통틀어 정수라고 부른다.
PHP에서 정수를 표현하는 것은 너무 자연스럽다.
실제로 수학에서 숫자를 표현하는 것과 완전히 같기 때문이다.

PHP에서 데이터의 형식을 막론하고 화면에 뭔가를 표현하는 방식으로 echo가 있다.

그리고 PHP는 반드시 하나의 구문이 끝나면 ;(세미클론)을 찍어야 한다.

예)
<?php
   echo 1;
?>

결과)

1

echo 말고 print()로 출력할 수도 있다.

예)

<?php
   print(1);
?>

결과)
1

데이터 타입은 이렇게 이해하면 된다.
0은 0이고 -1은 음수가 되는 것이다.
실수를 표현하고 싶다면 1.1이라고 적으면 된다.
1). print

print는 입력이 한 개이고 리턴 값을 가진다.
항상 1이라는 숫자를 리턴한다.
print는 함수는 아니지만 함수처럼 사용할 수 있다.

사용 예)

int print( string $arg) - 문자열 하나를 출력

-int는 리턴 값이 정수형이라는 것을 말하며 $(변수이름)는 변수, string은 문자열을 뜻한다.

2) echo

echo는 하나 이상의 문자열을 출력한다.
입력 값이 여러 개라는 이야기다.
아무것도 결과물로 돌려주지 않는다.
물론 html로 출력해주는 역할을 하지만 리턴 값은 없다.
함수형으로도 사용할 수 없다.

사용 예)

void echo (string $arg1 [,string $...]) - 하나 이상의 문자열을 출력

void는 리턴 값이 없다는 것을 말하며 string은 문자열을 말하고 $는 변수, string은 문자열을 뜻한다.


echo "I´m about to learn PHP!";
echo "This ", "string ", "was ", "made ", "with multiple

문자열 사이에 태그들을 넣을 수 있다.

*php와 문자열

컴퓨터 언어에서는 여러 가지 역사적인 이유로 인해 문자를 string이라 쓴다.
string은 문자가 모여있다는 의미에서 나온 표현으로. 프로그래밍에서 string은 굉장히 중요한 표현으로서 한국어로 문자열이라 부른다,
그럼 php에서는 어떻게 문자를 표현하는 보면 된다.

string literal이라는 표현이 나오는데, literal이라는 것은 어떤 데이터를 그 언어에서 표현할 때 쓰는 기호라고 생각하면 된다.
이 가운데 string을 표현하는 기호는 single quoted, double quoted이다.

사용 예)

<?php
	echo 'hello world';
?>

'hello world' 자체는 string literal이라고 해서 문자를 표현하는 방법이고, 이 상태 그대로 쓸 수 없다.

화면에 출력하기 위해서는 echo를 쓰면 된다.

여기에 있는 작은 따옴표(')는 영어로 single quoted이다.
이것 말고 다른 대안도 있다.
' 대신 "로 묶어도 된다.
이때 한 가지 주의할 점은 '로 시작하면 '로 끝나야 하고 "로 시작하면 "로 끝내야 한다는 것이다.

경우에 따라 '를 문자로 표현해야 한다면 바깥쪽을 "로 묶고 안쪽을 '로 묶으면 된다.

다른 방법으로는 일시적으로 그 기호의 역할을 해제하는 방법으로 엔터와 백스페이스 사이에 있는 \ 기호(역슬래쉬)를 앞에 가져다 놓으면 일시적으로 그 역할에서 해제되고 순수한 문자로 사용된다.

사용 예)
echo "연습\"장\" 파일";

결과)

연습"장" 파일

1). 문자열 결합 연산자(concatenation operator)

문자열 결합 연산자는 "문자"+"문자"를 해주는걸 얘기한다.

사용 예)

echo "연습"."파일";
지금은 왜 결합 연산자가 필요한지 모르겠지만 나중에는 많이 쓰게 될 것이다.
예제에서 보다시피 "연습파일"라 쓸 수 있겠지만 "연습"다음에 .을 쓰면 .이라는 결합 연산자는 좌항에 있는 "연습"문자열과 우항에 있는 "파일" 문자열을 합쳐서 문자열로 만든다.

한가지 중요한 점은 .이라는 연산자로 좌항과 우항을 결합해 하나의 문자열로 만들어낼 수 있다는 것이다.

연산자 말고 문자열과 관련된 함수도 있다.
예를 들어, "hello world"라는 문자열이 있다면 이 문자열을 가지고 여러 가지 작업을 하고 싶어진다.
"hello world"는 몇 개의 문자로 이뤄져 있는가와 같은 것 말이다.
함수를 이용하는 예를 들자면 문자열의 길이를 알고 싶을 때 문자열을 strlen()으로 감싸면 그 문자가 몇개의 문자로 이뤄져 있는지 알 수 있다.

1-2) strlen()

strlen()은 문자열의 배열의 길이를 알려준다.

사용 예)

 echo strlen("hello world");

결과)

11

"hello world"가 몇 개의 문자로 이뤄져 있는지 알고 싶다면 strlen() 로 감싸서 echo로 출력해 보면 알 수 있다.
나중에 데이터를 많이 처리하다 보면 엄청나게 많은 텍스트가 몇 개의 문자로 이뤄져 있는지 알고 싶을 때가 있다.
그런 경우 이런 함수가 많이 도와줄 것이다.

지금까지 string literal과 문자열을 php에서 표현하는 방법을 살펴봤고 그 문자열을 다루는 방법으로 결함 연산자를 살펴봤으며, 연산자는 아니지만 문자열이 몇개의 문자로 이뤄져 있는지 알려주는 함수도 살펴봤다.

*php의 변수

php에서는 변수명 앞에 반드시 $를 넣는다.
그래서 따옴표로 묶이지 않은 $로 시작하는 문자를 보면 그것은 변수라는 것을 알 수 있다.

사용 예)

$a = 10;
echo $a +1;

*php의 url파라미터

어떤 대상을 분석할 떄 항상 대상으로 들어오는 입력은 무엇이고, 출력이 무엇인지 살펴본다,
소프트웨어도 마찬가지이다.
소프트웨어들은 각자 성격에 따라 입력과 출력이 다르다.

예를 들어 계산기는 마우스 클릭을 통해 계산기에 값을 입력하고, 화면에 입력한 결과를 보여준다.
즉, 입력에 따른 어떠한 동작을 한 다음에 그 결과를 출력한다.
모든 소프트웨어들이 동작하는 기본적인 모습이다.
그런데 지금 배우고 있는 php는 이러한 데스크톱 애플리케이션을 위해 고안된 언어가 아니고, 웹 애플리케이션을 위해 고안된 언어이다.
그래서 여기서는 php로 만든 웹 애플리케이션에는 어떤 입력이 있을 수 있고, 그에 따른 출력이 무엇인지 살펴보겠다

먼저 실슴을 위해 egoing.html이라는 파일을 만든다.  egoing.html이라는 파일을 "egoing"에게 인사를 건네는 웹 페이지라고 생각해 보자.
leezche.html 역시 마찬가지로 "leezche"에게 인사를 건네는 웹 페이지이다.
이제 인사를 하고 싶은 사람들에게 인사를 하려면 그 사람들에게 "egoing"에게는 egoing.html의 주소를 leezche에게는 leezchehtml의 주소를 알려줘야 한다.
그런데 2명이 아닌 1억명에게 알려줘야 한다고 생각해보면 1억개의 웹 페이지가 필요한데, 1억 개의 웹 페이지를 만든 상태에서 '안녕하세요' 가 아닌 'hi'로 바꿔야 하는 참담한 경우가 생긴다면 1억 개를 전부 바꿔야 한다.
이처럼 위치기에 빠진 상황을 php가 해결해준다.

다음과 같이 parameter.php라는 파일을 만들고 '안녕하세요'를 전달하는 웹 페이지를 구성해보자.

<!DOCTYPE html>
<html>
	<head>
	<meta charset="utf-8">
	</head>
	<body>
		안녕하세요. egoing님
	</body>
</html>

그런데 나는 "egoing"이라는 값을 바꾸고 싶을때.. 그것도 입력에 따라서, 지금 만들고 있는 이 애플리케이션은 parameter.php라는 이름을 갖고 있는 애플리케이션이다.
그리고 이 애플리케이션에게 입력값을 주고 싶다면 http://127.0.0.1/parameter.php?name=egoing을 웹 브라우저의 주소창에 입력한다. 이것은 parameter.php라 하는 PHP애플리케이션에게 'name은 egoing이다' 라는 입력값을 준 것이다. 그럼 parameter.php라 하는 웹 애플리케이션은 name의 값인 "egoing"을 출력하고, 같은 원리로 name의 값을 "leezche"라 지정하면 "egoing"이 있던 자리에 "leezche"를 출력하게 함으로써 단 하나의 parameter.php라는 php애플리케이션을 통해 무한히 많은 웹 페이지의 무한히 많은 사람에게 인사를 건넬 수 있다는 폭팔적인 효과를 얻게 된다.
이를 위해 코드에서 "egoing을 출력하는 부분을 바꿔보겠다.

<!DOCTYPE html>
<html>
	<head>
	<meta charset="utf-8">
	</head>
	<body>
		안녕하세요. <?php echo $_GET['name'];?>님
	</body>
</html>

"egoing" 자리에 URL로 전달된 name의 값에 해당하는, php에서 약속된 특수한 이름의 변수를 넣겠다.
바로 $_GET['name']이다.

http://127.0.0.1/?name=leezche 주소 창 입력을 하면

'안녕하세요 leezche님'이 된다. 그리고 leezche 대신 graphittie 로 바꾸면 안녕하세요 graphittie님이 된다.

즉 parameter.php라는 애플리케이션을 만들었고, 그 애플리케이션의 입력값을 URL을 통해 준 것이다.
그 URL에 따라 parameter. PHP라는 애플리케이션은 echo라고 하는 출력 명령을 통해 각 경우마다 다르게 출력할 수 있게 되는 것이다.

이것을 통해 어떤 폭발적 효과를 얻었나?
이제 사람이 많아도 주소의 name 값을 바꾸는 것만으로 인사를 할 수 있는 어마어마한 애플리케이션을 만든 것이다.
그 과정에서 $_GET['name']에 있는 대괄호는 무엇인지 몰라도 된다.(이 부분은 나중에 차차 알게 된다.)

URL에 name 대신 title로 지정하면 애플리케이션이 작동하지 않는다.

하지만 코드의 $_GET['name']을 $_GET['title']로 바꾸면 정상적으로 작동한다.

GET과 POST

HTML의 form을 이용하여 값을 전송하는 방식은 get과 post 두 가지가 있다.
php로 그 값을 받아서 사용하는 방법을 알아보자

GET방식으로 전송한 경우

다음은 GET방식으로 값을 전송하는 간단한 예제이다.

    <form method="get" action="form-action.php">
      <p><label>Color : <input type="text" name="color"></label></p>
      <p><label>Sport : <input type="text" name="sport"></label></p>
      <p><input type="submit" value="Submit"></p>
    </form>

결과 )
url 주소 끝에 ?가 붙고 color=Red&sport=Basketball 이런식으로 붙는다.
GET 방식으로 전송된 값은 $_GET으로 받는다.

<?php
  $color = $_GET['color'];
  $sport = $_GET['sport'];
?>

 <body>
    <p>Color is <?php echo $color ?>.</p>
    <p>Sport is <?php echo $sport ?>.</p>
  </body>

POST 방식으로 값을 전달할 경우, URL에 아무 흔적이 남지 않는다.
POST 방식으로 전송된 값은 $_POST로 받는다.

그리고 만약 인사와 주소를 둘 다 넣고 싶다면 어떻게 해야하는지 보자.
먼저 코드에 <?php echo $_GET['address'] ?>를 추가한다.

예)
안녕하세요. <?php echo $_GET['adrress'];?>에 사시는<?php echo $_GET['name']; ?>님

URL = http://127.0.0.1/?address=서울&name=leezche

결과)

안녕하세요. 서울에 사시는 leezche님

이것은 URL의 규칙이다.
이것은 PHP와 상관없다.
이 파일의 이름 뒤에 ?가 오고 그 뒤에 파라미터라고 하는 입력값이 온다.
그리고 입력값과 입력값을 구분하는 구분자는 &라는 특수한 기호를 쓴다.
만약 입력값을 추가하고 싶다면 &를 추가하고, 나이라면 &age=20처럼 지정하면 된다.

아직 알 수 없는 것과 알 수 있는 것이 섞여 있다.
알 수 없는 것은 대괄호 문법이다.
알 수 있는 것은 $_GET은 변수의 이름이고 이 URL을 통해 전달되는 값을 애플리케이션에서 가져오려면 URL의 값이 name이면 $_GET['name']으로 하면 되고 address이면 마찬가지로 $_GET['adress']로 지정하면 된다는 것을 일단 경험적으로 파악하고, 나중에 문법을 배움으로써 이론화하면 되겠다.

이렇게 해서 php라는 웹 애플리케이션이 URL을 통해 입력값을 전달받고 그것을 출력하는 방법을 살펴봤다.


*URL파라미터의 활용

각 페이지에 접근할 때마다 URL의 id라고 하는 URL 파라미터의 값이 바뀌고, 그에 따라 웹 페이지의 내용이 바뀐다.
이를 한 번에 할수는 없고 각 목록을 클릭했을 때 제목이 프로그래밍적으로, 동적으로 바뀌는 애플리케이션을 만들어 보겠다.

우선 index.php라는 파일을 만들겠다.
기본적인 골격을 만든 다음 이 수업의 큰 제목인 WEB을 입력하겠다.

<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title></title>
</head>
<body>
	<h1>WEB</h1>
</body>
</html>

제목 아래에 HTML, CSS, Javascript가 있는 글 목록을 <ol>, <li> 태그를 이용해 작성한다.
그리고 각 목록에 링크를 걸어서 만약 HTML 목록을 클릭하면 주소가 "index.php?id=HTML'로 바뀌도록 만들 것이다. 따라서 href 속성을 index.php?id= 뒤에 HTML은 'HTML'로, CSS는 'CSS'로, JavaScript는 JavaScript'로 설정한다.

결과를 보면 클릭할 때마다 적당한 주소로 바뀐다.
그럼 이제 URL의 id 값이 무엇이냐에 따라 현재 페이지의 제목을 정하는 기능을 구현해보겠다.
제목은 <h2> 태그 안에 넣을 것이며 'Lorem'을 입력한 뒤 탭 키를 눌러서 아무 의미도 없는 본문을 만들었다.

<h1>WEB</h1>
	<ol>
		<li>
			<a href="index.php?id=HTML">HTML</a>
		</li>
		<li>
			<a href="index.php?id=CSS">CSS</a>
		</li>
		<li>
			<a href="index.php?id=JavaScript">JavaScript</a>
		</li>
	</ol>
	<h2>
		<?php
			echo $_GET['id'];
		?>
	</h2>
	Lorem Ipsum....

<h2> 태그 안에 PHP코드의 시작을 알리는 <?php를 쓰고, 파라미터 값이 id이므로 echo $_GET['id']라는 코드를 넣으면 URL의 id파라미터값이 무엇이냐에 따라 자동으로 제목이 프로그래밍적으로 만들어지는 코드를 작성할 수 있다.

*함수의 사용

프로그래밍 수업을 들어보면 함수는 맨 뒤에 나고나, 객체라는 것이 나오기 전에 등장한다.
함수라는 것은 다소 어려울 수 있는 개념이다. 아직 함수가 무엇인지 잘 모르지만 어쨋든 함수라는 것을 만들어서 사용할 수 있다.
함수를 만드는 방법은 이 수업의 후반부에서 다시 배울 것이며, 이번 시간에는 함수를 만드는 것이 아니라 다른 사람이 만든 함수를 사용하는 방법을 살펴볼 것이다.

저자는 공부할 때 생산자로 출발하면 안된다고 생각한다.
소비자로서 충분히 사용해 보고 그것이 무엇인지 이해하고, 나중에 생산자가 되는 편이 훨씬 쉽다.
그것을 써본 적이 없는데 생산자가 되면 어렵다. 그래서 이번 시간에는 함수를 사용하는 방법을 먼저 살펴보겠다.

프로그램이란 말은 무슨 말일까?
옛날에 오페라에서 시간의 순서에 따라 음악이 연주되는데 연주되는 곡의 순서를 프로그램이라고 했다. 우리가 지금 배우고 있는 것은 프로그램을 만드는 방법인 프로그래밍이다.
프로그래밍이라는 것은 여러분이 목적한 의도에 따라 지금부터 배울 함수를 시간 순서대로 실행되도록 코드를 작성하는 행위라고 할 수 있기 때문에 지금부터 살펴볼 함수라는 것은 프로그래밍의 기본적인 원자 또는 부품이라고 할 수 있다.

function.php 파일을 만들고 여러 가지 함수와 관련된 코드를 작성해 보겠다.
이미 함수는 문자열을 배울 때 배웠다. [strlen()=문자열 배열 길이 구하는법]
문자열이 몇 개의 문자로 이뤄져 있는지 알아내는 방법이였다.
다음고 같이 $str 이라는 변수에 아무 의미 없는 텍스트를 넣어보겠다.
이 텍스트에 echo를 사용하면 문자열이 출력되겠다.

$str이라는 변수에 담긴 문자열이 몇 개의 문자로 이뤄져 있는지 알고 싶다면 검색을 통해 찾아보면 된다.
검색 엔진에서 추천 검색어로 'php string length'를 검색하면 된다.

살펴보sl strlen이라는 것을 쓰면 되는데 이것이 바로 함수이다.
그런데 우리는 strlen을 만든 적이 없기 때문에 PHP에 내장된 함수를 사용하면 된다.

strlen()의 괄호 안에 길이를 알고 싶은 문자를 넣으라는 뜻이다.
괄호 안에 $str을 넣어보자
그러면 결과는 int, 즉 정수가 된다는 뜻이다.
예를 들어, echo 1;은 1에 대한 표현식이다.
echo 1+1;을 보자. +는 이항 연산자인데, 좌항에 있는 1과 우항에 있는 1을 더해서 2로 바꾸는 표현식이다.
즉, strlen()이라는 함수는 괄호 안에 들어있는 입력값을 계산한 다음, 그 결과를 정수로 교체하는 표현식이다.

<?php
		$str = "Lorem Ipsum is simply dummy text"; // 변수에  string 값 저장
		echo $str."<br>";	// 변수 출력
		echo strlen($str);//텍스트의 배열의 길이
	?>

즉 함수는 괄호 안으로 입력이 들어오면 복잡한 과정을 거쳐서 계산하고, 그 결과를 반환하는 작은 프로그램이라고 할 수 있다.

몇 가지 조금 더 살펴보자면, 코드에서 문자열을 줄바꿈하기 위해 마침표를 추가하고 줄 바꿈했을 때, 페이지를 새로고침하면 결과 문자열도 줄바꿈이 됐나요? 안 된다. 그 이유는 코드에서의 줄 바꿈을 HTML 에서는 무시하기 때문이다.

줄 바꿈하기 위해서는 <br?을 써야 한다. 그런데 php는 아주 신통하게도 웹의 화신 같은 언어이기 때문에 웹에서 사용할 만한 여러 가지 기능을 제공한다.
검색 엔진에서 'php new line to br'로 검색하면 된다.

그럼 nl2br()이라는 함수를 찾아주는데, 이 함수의 설명을 보면 문자열의 모든 줄바꿈앞에 태그를 삽인한다고 적혀 있다.
그리고 입력값으로 문자가 들어고는데, 추가적인 입력값으로 섬세하게 제어할 수 있다는 뜻이며, 지금 당장은 이 부분을 무시한다.
다음과 같은 코드를 실행해 보자.

<h1>function</h1>
	<?php
		$str2 = "sdfdsf";
		$str = "Lorem Ipsum is simply
				dummy textfsdfsdf"; // 변수에  string 값 저장
		echo $str2.$str;	// 변수 출력
		echo strlen($str);//텍스트의 배열의 길이
	?>
	<h2>nl2br</h2>
	<?php
		echo nl2br($str);
		echo nl2br($str2);
		echo $str2.$str;
	?>

이 코드를 사용한 곳에는 줄 바꿈이 일어난 것을 확인할 수 있다.

웹 페이지에서 페이지 소스 코드 보기를 들어가면 <br>태그가 자동으로 들어간걸 확인할 수 있다.

이렇게 해서 지금까지 함수라고 하는 문법을 알게 됐고, 메뉴얼을 보는 법, 검색 엔진을 통해 필요한 기능을 찾아내는 법을 살펴봤다.

*함수의 활용

지금까지 만들고 있는 예제를 보면 클릭했을 때 제목이 바뀌는 것을 알 수 있었다.
제목이 바뀌는 것은 이전 시간에 살펴본 $_GET['id']를 사용했기 때문이다.
이것과 함께 본문은 요지부동 상태이다.
링크를 클릭했을 때 제목이 바뀌듯, 본문도 바뀌게 하겠다.

그러기 위해 새로운 디렉토리를 만들겠다.
디렉토리 이름은 data이고, 이 디렉토리에는 본문이 저장될 것이다.

HTML이란 파일을 만들고 'Html is..."와 같은 내용을 삽입하고, css파일과 javaScript 파일 역시 동일하게 생성한다.

목록중 CSS를 클릭한다는 것은 data 디렉토리에 있는 CSS파일의 내용을 본문에 추가하고 싶은 것이다.
이를 위해서는 무엇이 필요한지 논리적으로 생각해 보자.
즉, id값이 'css'라고 한다면 본문의 내용으로 data/id값에 해당하는 파일의 내용을  echo로 출력하면 된다.
이를 위해 필요한 것은 파일을 읽어야 하는데, PHP에는 파일을 읽기 위해 고안된 내장 함수가 있을 것 같다.
검색 엔진에서 ' php file read function'으로 검색하면 다음과 같은 페이지가 나온다.

file_get_content()라는 함수가 있다.
첫 번째 자리에 문자열 형식으로 파일의 이름이 오고, 두번째, 세 번째 값으로는 다른 내용을 지정해 세밀하게 조정할 수 있다. 예제를 보겠다.

보다시피 file_get_content() 괄호 안에 파일명을 쓰면 이 함수는 파일의 내용이 된다는 것을 알려준다.

그럼 file_get_contents() 함수를 부품으로 사용해 index.php 파일을 우리가 원하는 형태에 가깝게 만들어 보자.

예)
	<h2>
		<?php
			echo $_GET['id'];
		?>
	</h2>
	<p>
		<?php echo file_get_contents("data/Html.php");	?>
	</p>

페이지를 새로고침 해보면 HTML,CSS,JavaScript에 따라 변화하는게 아니고 고정되어 있다.

우리가 원하는 것은 ID값이 무엇이냐에 따라 data 밑에 있는 적당한 파일명을 가져오는 것이다.
file_get_contents("data/Html.php);에서 HTML이라고 돼 있는 부분을 .$_GET['id']로 바꾸고 결과를 확인해보겠다.

	<h2>
		<?php
			echo $_GET['id'];
		?>
	</h2>
	<p>
		<?php echo file_get_contents("data/".$_GET['id'].".php");	?>

새로고침 해보면 id에 맞게끔 해당.php파일에 본문이 보이는 걸 볼 수 있다.

이처럼 file_get_contents()라는 함수를 통해 id값으로 들어온 것을 이렇게 프로그래밍적으로 PHP를 통해 경로로 전환한 다음 file_get_contents()의 입력값으로 전달하면 그 함수는 입력값에 들어온 경로에 해당하는 파일을 찾아 그것을 표현하는 표현식이라는 것을 볼 수 있다.
물론 이 예제에는 교육적으로는 좋은 예제이지만 현실에서는 이 코드를 그대로 쓰면 안된다.
복잡한 이슈때문에 언급하진 않았지만 보안 문제나 규모가 문제가 생기기 때문에 신뢰할 수 없는 사람들이 사용할 수 있는 환경에서 이런 코드로 동작하는 웹 어플리케이션을 실행하면 절대로 안된다.

*제어문 예고

이번 시간에는 컴퓨터 프로그래머들의 위대한 성취에 대한 이야기를 해보고, 컴퓨터 프로그래밍, 프로그램이란 말의 의미를 곱씹어보겠다.
프로그램이란 말 속에서 '순서' 라는 의미가 깊숙히 자리 잡고 있다.

우리가 어떤 일을 한다고 했을 때 그 일을 한다는 것은 두 가지로 구성된다.
그 일을 이루고 있는 작업과 시간에 순서에 따라 실행한다는 것이다.
작업과 실행 순서, 이 두 가지가 일을 구성하는 핵심이라고 생각한다.
컴퓨터를 통해 일을 한다는 것도 마찬가지일 것이라고 생각한다.
컴퓨터를 통해 일을 한다는 것은 컴퓨터가 가지고 있는 기능들을 우리가 하고자 하는 일의 목적에 맞게 시간 순서에 따라 실행한다는 것이다.

그런데 우리가 하는 일 중에는 반복적인 일이 있다.
또는 실수하기 쉬운 일이 있고, 사람이 하기 싫은 일이 있따.
또 여러 사람이 필요로 하는 일이 있다.
그러한 일일수록 자동화하고 싶어진다.
컴퓨터 프로그래머들은 이러한 일들을 자동화할 수 있도록 컴퓨터 프로그래밍 언어라는 것을 만들었다.

코드를 위에서 아래로 쭉 써내려가면 시간에 순서에 따라 그 코드가 가리키는 기능들이 실행되는 것이다.
그런데 컴퓨터 프로그래머들은 그것이 가장 중요하긴 한데 그것 말고도 두가지 중요한 기능을 고안해낸다.
조건문과 반복문이라는 것이다.

조건문은 시간 순서에 따라 실행되다가 어떤 조건에 따라 다른 작업이 실행되는 것이다.

반복문은 시간 순서에 따라 기능이 실행되다가 어떤 조건을 만족하는 동안에 특정 작업이 반복적으로 실행하게 되는 것이다.

즉, 프로그램은 기본적으로 시간 순서에 따라 실행되는데, 그 흐름을 제어해서 조건에 따라 다르게 동작하게 하는 것이 조건문, 반복해서 동작하게 하는 것이 반복문이다.
그래서 조건문과 반복문은 컴퓨터가 갖고 있는 시간 순서에 흐름이라는 것을 제어한다는 측면에서 제어문이라고도 한다.
이제부터 제어문의 가장 큰 두 가지 축인 조건문과 반복문을 배우겠다.

*조건문 예고

index.php에 목록의 링크를 클릭할 때마다 페이지가 열린다.
그런데 'WEB'을 클릭했을 때는 깔끔하게 127.0.0.1/index.php와 같이 나오고 본문에는 'HOME'에 해당하는 콘텐츠가 나오게 하고 싶다면 지금까지 배운 내용가지고는 아무것도 할 수 없다.

*불리언(Boolean)과 비교 연산자

여기서는 Boolean 이라는 새로운 데이터 타입과 비교 연산자라는 것을 배울 것이다.
불리언과 비교 연산자는 그 자체로는 쓸모가 없기 때문에 조건문까지 가야 비로소 이것이 얼마나 혁명적인 도구인지 알 수 있다.

boolean이라는 데이터 타입은 특이하게도 TRUE 아니면 FALSE두 개의 데이터로만 이뤄져 있다.
데이터 타입 자체는 의미가 없고 비교 연산자와 관련이 있다.

comparison.php라는 파일을 만들고, 기본적인 HTML 골격을 작성한다.
앞서 어떠한 정보를 출력할 떄 echo 나 print()라는 함수에 값을 넣으면 된다고 말했지만
이번에는 var_dump()라는 것을 사용해보겠다.
var_dump()에 값을 넣으면 입력값을 출력하며, 그와 동시에 입력값의 데이터 타입까지 알려준다.

만약 var dump(11);이라고 작성하면 '11'을 출력하면서 int타입의 정수라는 것까지 알려준다.

사용 예)

<h1>Comparison Operators & Boolean data type</h1>
    <?php
        var_dump(11);
    ?>

결과)

int(11)

만약 따옴표로 11을 묶으면 '11'은 문자열로 나타낸다.

var_dump()는 실제 서비스에서는 쓸 필요가 없지만 개발 과정에서는 숱하게 사용할 함수이다.

var_dump(1+1); 은 int(2)를 출력한다.
+라는 산술 연산자는 좌항에 있는 값과 우항에 있는 값을 더한 결과가 되는 표현식이기 때문이다.
더하기라는 산술 연산자는 좌항에 우항을 더해서 숫자라는 데이터 타입이 되는 산술 연산자이기 때문이다.

var_dump(1==1);

==는 비교연산자라는 것인데, 이것의 역할은 좌항에 갑소가 우항의 값을 비교해서 두 값이 같다면 ture를 같지 않다면 false를 돌려주는 것이다.


var_dump(1==1); 의 결과

bool(true)

*조건문의 형식

1. if문

if(expr)
	statement

위 형식을 보면 if가 오고 괄호 사이에 expr이 나오는데, expr은 expression의 약자이다.
한국어로는 표현식이다. 즉 괄호 안에 값이 온다는 것이다.

conditional.php 라는 파일을 만들어 보자, 앞에서 누누이 설명했듯이 컴퓨터 프로그래밍 언어에서 가장 기본적인 동작 방법은 시간 순서에 따라 동작한다는 것이다.

<?php
        echo '1<br>';
        echo '2<br>';
        echo '3<br>';
    ?>

즉, 시간 순서에 따라 위에서 아래까지 순차적으로 실행된다는 것이 가장 기본적이고 중요한 컴퓨터 프로그래밍에서의 부동의 원리라는 것이다.
위와 같이 사실 아무 의미 없는 코드를 작성했지만 적당한 기능, 즉 함수를 배치함으로써 정말 혁명적인 것들을 할 수 있다.
코드를 일일이 반복적으로 실행할 필요가 없다.
조건문이라는 것을 사요하면 코드가 실행되는 코드가 실행되는 순서의 흐름을 바꿀 수 있다.

 echo '1<br>';
        if(true){
            echo '2<br>';
        }
        echo '3<br>';
    ?>

 echo '1<br>';
        if(true){
            echo '2<br>';
        }
        elseif(false){
	echo '5<br>';
        else{
	echo '4<br>';
        echo '3<br>';
    ?>

* 조건문의 활용

예제에 'WEB'에 대한 링크를 달고, 링크의 href값으로 index.php를 넣겠다.
그럼 'web'을 클릭하면 주소가 깔끔하게 index.php인 페이지가 나오고 본문에는 아무것도 안나와야한다.

사용 예)

<h1><a href="index.php">WEB</a></h1>

그런데 만약 URL에 id 값이 없다면 'welcome'을 출력하고 싶다고 해보자.
그리고 id 값이 없는 상태에서 data라는 디렉토리를 대상으로 file_get_contents()를 실행하니 문제가 있다.
이를 위해 코드를 한국어로 먼저 적어 보겠다.

<?php
	만약에 id 값이 있따면
	echo $_GET['id'];가 실행되고
	없다면
	echo 'welcome';
?>

위의 내용을 php코드로 바꿔보면

<?php
	if(){
	echo $_GET['id'];
	else{
	echo 'welcome';
	}
?>

if뒤에 있는 괄호에 무엇이 들어가면 좋을까..
검색 엔진에서 'php check value exists'를 검색해 보면 isset()이라고 나온다.

isset()이라는 함수는 값으로 들어온 것이 값을 가지고 있느냐 가지고 있지 않느냐에 따라 boolean값,
즉 true나 false가 반환된다고 나와있다.

jquery로 치면 is()랑 같은건가...?

$var라는 변수를 isset()에 넣으면 isset($var)라는 값이 true가 된다는 뜻이다.

$var는 빈 문자지만 $var라는 변수의 값이 세팅돼 있기 때문에 값이 세팅됐는지를 판별하는 isset($var)은 true가 되는 것이다.

예)

$a = "test";
$b = "anothertest";

var_dump(isset($a)); //true
var_dump(isset($a,$b));//true

unset($a); // unset()함수는 변수의 데이터 값을 없애는 역할을 한다.

var_dump(isset($a)); //false
var_dump(isset($a,$b)); //false

$foo = null;
var_dump(isset($foo)); //false

위의 예제를 활용해서 index.php에 있는 값을 수정한다면..

일단 h2영역 부분)

<h2>
	<?php
		if(isset($_GET['id'])){
			echo $_GET['id'];
		}else{
			echo "welcome";
		}
	?>
</h2>

$_GET['id']라는 값이 있다면 h2부분에  해당 id에 맞는 값이 출력될 것이고, 만약 없다면 welcome을 출력할 것이다.

이와 같은 방법으로 밑에 본문 내용도 똑같이 바꿔줄 수 있다.

<?php
	if(isset($_GET['id'])){
		echo file_get_contents("data/".$_GET['id'].".php");
	}else{
		echo "welcom to php";
	}
?>

$_GET['id']라는 값이 있다면 본문 내용에 해당file_get_contents('data/'.$GET_['id'].'.php')의 내용이 삽입되고 만약에 없다면 welcome to php를 출력한다.

이처럼 id 값이 없다면 'Welcome'과 welcome to php가 출력되고 html을 클릭하면 id 값이 있기 때문에 if문 뒤에 코드가 실행되는 애플리케이션을 만들 수 있게 되는 것이다.
즉, 애플리케이션이 특정 상황에서 좀 더 섬세하게 구동할 수 있는 방법을 찾았다고 할 수 있다.

*반복문

주소가 무엇이냐에 따라 data라는 디렉토리에서 적당한 파일을 열어서 웹 페이지를 자동으로 생성하고 있다.
이것만으로도 정말 이전과 비교하면 큰 도약이 있었다.
새로운 페이지를 추가하기 위해 data디렉터리에 php를 추가 해보겠다.
그리고 php에 대한 설명을 넣고, 페이지를 새로고침하면 어떻게 되나?
데이터는 있지만 글 목록이 없기 때문에 아직 접근 할 수가 없다.

data 디렉토리에 파일이 추가되면 php가 알아서 이를 인식하고 방금 만든 HTML태그를 프로그래밍적으로 자동으로 생성해준다면 얼마나 좋을까?
그렇게 하는 수단이 바로 반복문이다.

<ol>
	<li>
		<a href="index.php?id=HTML">HTML</a>
	</li>
	<li>
		<a href="index.php?id=CSS">CSS</a>
	</li>
	<li>
		<a href="index.php?id=JavaScript">JavaScript</a>
	</li>
	<li>
		<a href="index.php?id=php">PHP</a>
	</li>
</ol>

따라서 목록을 만드는 위 코드를 php 코드로 바꿔보겠다.
먼저 한국어로 써보겠다.

여기서 중요한 것은 문법보다 우리가 무엇을 하고자 하는지 논리적으로 설명하는 것이다.

<ol>
	<?php
		data파일 디렉터리에 있는 파일의 목록을 가져오세요.php님
		그 파일의 목록 하나하나를 <li>와 <a> 태그를 이용해 글 목록을 만드세요.
	?>
</ol>

위와 같은 작업을 php에게 시킨다면..

<ol>
	<?php
		$list = scandir('data'); /*scandir(string $directory)함수는 지정된 경로 내의 파일과 디렉토리를 나열한다*/
				  //directory에서 파일 및 디렉토리 의 배열 을 반환 한다.
				  //$list라는 변수에 값을 저장
		$i = 0; //변수i에 0숫자 저장
		while($i < count($list)){/*몇 개의 값을 가지고 있는지 구해야 하는 경우 배열의 개수를 반환하는 				      함수 count()를 사용할 수 있습니다. count() 함수를 사용하면 해당하는 				      배열이 몇 개의 값을 가지고 있는지 계산하여 숫자로 반환합니다.*/
			if($list[$i] != '.'){
				if($list[$i] != '..'){
					?>
						<li><a href="index.php?id=<?=$list[$i]?>"><?=$list[i]?></a></li>
<?php
	}
}
	$i = $i + 1;
}
?>

php코드를 통해 data 디렉터리에 있는 파일 목록을 반복해서 꺼내서 프로그래밍적으로 <li> 태그를 생성해 낸다면 data디렉터리에 MYSQL이란 파일을 추가했을 뿐인데, 페이지를 새로고침하면 MYSQL이라는 목록이 추가되고 index.php라는 PHP애플리케이션의 뚜껑을 열고 그 안에 있는 내용을 수동으로 수정하지 않아도 된다는 점이다.
그러면 data라는 디렉터리에 콘텐츠를 추가하는 데만 신경쓰면 된다는 점이다.

*반복문의 형식

while이라고 하는 가장 단순하면서 지금까지 배운 것들을 종합적으로 복습할 수 있고 가장 자유도가 높은 반복문을 사용하겠다.
while 반복문의 형식을 보면 다음과 같다.

예)

while(expr){
	statement
}

앞서 살펴본 if문의 형식은 다음과 같다.

if(expr){
	statement
}

반복문 역시 똑같다.
expr부분에 표현식이 오는데 expr이라는 것과 statement의 차이는 expr에는 값이 오는 것이다.
또는 최종적으로 값이 되는 것이 expr에 온다.
예를 들어 1과 1+1은 expr에 올 수 있다.
그러나 if 문 자체는 값이 되지 않기 때문에 statement라 한다.
그래서 expr에 값이 아닌 statement가 오면 이상하다.
그리고 statement에는 순수하게 값만 오면 안되고 while 문이나 if문이 와야 한다.
그래서 expr과 statement는 프로그래밍에서 문법을 구성하는 양대 축이다.
대부분의 문법은 expr과 statement 중 하나이다.

이렇게 해서 while문의 형식을 확인했다.
while 문의 expr 자리에는 true나 false 같은 불리언 데이터 타입이 온다고 생각하면 된다.
다른 것이 와도 되지만 지금 단계의 학습에서는 앞서 말한 내용처럼 생각하면 된다.
그리고 if문에서의 expr처럼 expr에 오는 불리언이 참이면 while 문의 statement가 실행되는데 statement가 실행되고, 다시 expr을 봐서 false면 실행이 끝나면서 더는 statement 부붑ㄴ이 실행되지 않도록 약속돼있다.
그래서 조건을 만족하는 동안 statement가 반복적으로 실행되므로 반복문을 영어로는 loop(루프)라고 한다.

먼저 loop.php 파일을 만든다.

<body>
    <?php
        echo "1<br>";
        echo "2<br>";
        echo "3<br>";
    ?>
</body>

위 코드를 실행하면 1,2,3이 순차적으로 출력된다.
그런데 프로그래밍하다 보면 어떤 조건을 만족하는 동안 2가 여러번 반복적으로 입력되게 하고 싶을 수 있는데,
이때 반복문을 쓰면 된다.
그러한 반복문 중 하나가 바로 while문이다.

while은 영어로 '~하는 동안에' 라는 뜻이 있다.
프로그래밍에서는 어떤 조건을 만족하는 동안 반복 하는 역할을 하기 때문에 이런 이름이 붙여졌다.

<?php
    $i = 0;
        echo "1<br>";
        while($i < 3){
            echo "2<br>";
            $i++;
        }
        echo "3<br>";
    ?>

while문에 boolean값을 넣어주게 되면 (ture값) 무한 반복되기 때문에 끝이 있는 값을 넣어주는게 좋다.

*배열의 형식

배열이란 주제는 반복문과 뗴려야 뗄 수 없는 관계에 있다.
문법으로 두 가지는 별개지만 이 두가지를 별개로 배우면 의미가 없다.

array.php파일을 만들고
그안에 배열을 만들것이다.

$coworks = array('egoing','leezche','duru','teaho');//배열을 만드는법 1 array()메소드 사용
$coworks2 = ['egoing2','leezche2','duro2','teaho2'];//배열을 만드는법 2 [] 안에 넣어서 정리

echo $coworks[1].'<br>'; // 배열을 부를때에는 [index]를 사용해 부른다.
echo $coworks2[1];

배열이라는 수납상자는 기본적으로 담고 싶은 어떤 값을 순서대로 담는 것이다.
그리고 순서대로 담으면 첫번째 자리인 0부터 시작하고, 순차적으로 번호가 부여되고 그 번호를 통해 값을 꺼낼 수 있다.
값을 꺼내는 것까지 했으면 그 다음으로 중요한 것은 무엇일까?

선반이 있다면 경우에 따라 선반에 대한 어떤 정보가 필요할 때가 있다.
바로 이 안에 짐이 몇 개가 들어있냐는 것이다.

검색 엔진에서 'php array total count'를 검색하면 count()가 나온다 js 에서는 var.length로 나타낸다.

count()는 배열 원소(elements)의 개수를 돌려주는 역할을 한다.
따라서 아래 코드를 실행하면 3이 출력된다.
배열 내 원소의 자릿수는 0,1,2며 개수를 셀 때는 1,2,3이다.

<?php
        $coworks = array('egoing','leezche','duru','teaho');
        $coworks2 = ['egoing2','leezche2','duro2','teaho2'];

        echo $coworks[1].'<br>';
        echo $coworks2[1]."<br>";
        var_dump(count($coworks));
    ?>

결과)

var_dump(count($coworks));의 값은

int(4)

위 출력 결과의 의미는 $coworks라는 변수가 가리키는 배열에는 값이 총 4개가 담겨 있다라는 뜻이다.
배열을 사용하다 보면 배열의 값을 추가하고 지우고 중간에 넣고 무작위로 섞는 작업들이 필요한데 이중에서 한두 가지만 살펴보겠다.

먼저 배열에 없는 값을 끝에 추가하고 싶다면 어떻게 해야할까?
php array add value를 검색해보자

검색결과로 array_push()를 살펴보겠다.

<?php
        $coworks = array('egoing','leezche','duru','teaho');
        $coworks2 = ['egoing2','leezche2','duro2','teaho2'];

        echo $coworks[1].'<br>';
        echo $coworks2[1]."<br>";
        var_dump(count($coworks));
        echo '<br>';
        array_push($coworks,'hi');
        var_dump($coworks);
    ?>

결과)

leezche
leezche2
int(4)
array(5) { [0]=> string(6) "egoing" [1]=> string(7) "leezche" [2]=> string(4) "duru" [3]=> string(5) "teaho" [4]=> string(2) "hi" }

array_push()라는 함수에 첫 번째 입력값으로 배열을 주고, 두번째 세번째 입력값으로 추가하고 싶은 값을 주면 된다.

$coworks라는 변수가 가리키고 있는 배열은 5개의 원소로 이뤄져 있고, 0번째에는 'egoing',마지막에는 hi가 있다.

$coworks 변수가 가리키는 배열 끝에 array_push()와 같은 방식으로 값을 추가하는 것이 아니라 첫번째 자리에 넣는다거나 중간에 넣는다거나 3번째 자리의 값을 지우려면 어떻게 해야할까

검색을 통해 알아보면 된다.
php array참조

unset($coworks[0]); // unset()함수는 괄호 안에 들어가는 값을 삭제한다.

*반복문과 조건문의 활용1

scandir()을 먼저 보겠다.

scandir ( string $directory [, int $sorting_order = SCANDIR_SORT_ASCENDING [, resource $context ]] ) : array

scandir()이라는 함수는 보다시피 입력값으로 첫 번째 자리에 문자열 형식으로 디렉터리가 들어온다.
directory는 스캔하려는 디렉터리의 경로를 적는다는 뜻이다.
그리고 이 함수의 설명 중 대괄호 부분은 써도 좋고 안 써도 좋다는 뜻이다
대괄호에 묶여 있찌 않은 것은 반드시 지정해야 하는 필수적인 내용이라는 의미를 갖는다.
아울러 이 함수를 실행하면 최종적으로 array가 되는 표현식이라 적혀있다.

<?php
$dir    = '/tmp';
$files1 = scandir($dir);
$files2 = scandir($dir, 1);

print_r($files1);
print_r($files2);
?>

Array
(
    [0] => .
    [1] => ..
    [2] => bar.php
    [3] => foo.txt
    [4] => somedir
)
Array
(
    [0] => somedir
    [1] => foo.txt
    [2] => bar.php
    [3] => ..
    [4] => .
)

예제를 보면 입력값으로 경로를 지정했을 때 결과가 배열이면서 파일의 이름이 배열에 담겨서 제공된다.

index.php에 있는 li부분을 지우고 다음과 같이 작성한다.

<?php
	$list = scandir('./data');
	var_dump($list);
?>

스캔하고 싶은 디렉터리는 index.php라는 현재 파일과 같은 디렉터리에 있는 data라는 디렉터리 이므로 scandir()안에 data라고 적어도 좋고, 좀더 명시적으로 index.php파일이 위치하고 있는 현재 디렉터리 아래라는 의미로 ./를 지정한다. (참고로 ../는 부모 디렉터리를 가리킨다.).
그런 다음 그 결과를 $list라는 변수에 담고 어떤 값을 리턴하는지 확인해 보겠다.

array(7) { [0]=> string(1) "." [1]=> string(2) ".." [2]=> string(7) "CSS.php" [3]=> string(8) "HTML.php" [4]=> string(14) "JavaScript.php" [5]=> string(9) "MYSQL.php" [6]=> string(7) "PHP.php" }

$list에 담긴 값은 배열이고, 원소가 7개이며, 첫 번째는 ., 두 번째는 .., 세 번째는 CSS, 네 번째는 HTML, 다음은 차례로 JavaScript, Mysql, PHP임을 알 수 있다.
예제에서 굉장히 중요한 첫 번째 부품을 가져왔다.
즉, scandir() 함수를 통해 data라고 하는 디렉터리 안의 파잉ㄹ을 가져올 수 있고, 그렇게 가져온 파일 목록을 배열에 담아서 돌려준다는 것을 알 수 있다.
배열은 이처럼 서로 연관된 데이터를 담는 그릇으로 쓰인다라는 점을 이번 시간에 느꼈다면 성공이다.

*반복문과 조건문의 활용 2

이전 시간에 scandir()이라는 보석 같은 함수를 발견했고, 그 함수를 이용하면 특정한 디렉터리에 소속돼 있는 파일 목록을 배열로 받아낼 수 있다는 것을 알았다.
이제부터 무엇을 해야 할지 생각해 보면서 배열에 담긴 각 원소를 하나씩 반복해서 꺼낸다.
더 이상 꺼낼 것이 없을 때까지 말이다.
그렇게 꺼낸 것을 이용해 <li> 태그와 <a>태그를 이용해 글 목록을 프로그래밍적으로 만들어내면 문제를 해결한 것이겠죠? 우선 $list라는 배열에 담긴 값을 반복문 없이 수동으로 사용해 보자.

echo "<li>$list</li>";

큰따옴표로 묶여 있는 경우에 $list라고 지정하면 PHP가 $ 뒤에 있는 이름을 변수라고 생각한다.
$list 배열에 있는 첫번째 요소를 가져와서 목록으로 만들어 보겠다.

echo "<li>$list[0]</li>";

결과)

1. .

이렇게 하면 .이 생성된다.

이번에는 배열의 모든 요소를 출력해보고, 출바꿈이 되도록 \n을 추가해 보겠다.
\n은 HTML이 아닌 일반적인 텍스트 문서에서의 줄바꿈을 의미한다.


echo "<li>$list[0]</li>";
echo "<li>$list[1]</li>";
echo "<li>$list[2]</li>";
echo "<li>$list[3]</li>";
echo "<li>$list[4]</li>";
echo "<li>$list[5]</li>";
echo "<li>$list[6]</li>";

결과)

.
..
CSS.php
HTML.php
JavaScript.php
MYSQL.php
PHP.php

보다시피 점들은 무시하고, $list[2]는 CSS, HTML ...등등
많은 운영체제가 현재 디렉터리를 의미하기로 약손한 기호로 .을 많이 쓴다.
그리고 현재 디렉터리의 부모 디렉터리를 의미하는 것으로 ..을 많이 쓴다.

scandir() 함수는 원하는 디렉터리 안에 있는 파일 목록과 현재 디렉터리를 의미하는 . 하나와 부모 디렉터리를 의미하는 ..을 배열에 담아 돌려주는 함수이다.
사실 앞에 있는 .과 ..은 필요 없으니 나중에 처리하겠다.

수동으로 코드를 보면 패턴이 있다.
각 숫자를 제외한 나머지는 똑같다.
반복되고 있다는 말이다.
이 반복 부분을 반복문을 통해 우리가 직접 코딩하지 않고도 코딩한 것과 똑같은 효과를 낼 수 있따.
지금까지 작성한 코든 주석처리(/**/)해놓고 새롭게 수정한다.

$list = scandir('./data'); //data파일을 스캔하여 배열형식의 값을 출력한다.
$i = 0; //배열의 순서를 나타내줄 값 및 반복문 횟수
while($i<count($list)){		//$i의 변수값이 $list배열의 길이 값보다 작을때까지 반복실행한다.
		echo "<li>$list[$i]</li>"; //data파일의 배열값을 <li>태그로 출력한다.
		$i++;		//$i의 값을 1증가시킨다.
}

data폴더에 파일을 생성하고 삭제하면 data디렉터리안에 파일의 개수만큼 반복문이 실행된다.

여기서 조금더 나아가, 각각의 목록은 클릭했을 때 링크가 되어야 한다.
$list[$i]를 <a> 태그로 감싸고 href의 속성값을 써야 하는데, PHP에서 큰따옴표는 문자가 끝나느 기호이므로 엉망이 된다.
그래서 큰따옴표를 입력하기 위해서는 큰따옴표가 php에서 문자의 시작과 끝을 나타내는 구분자가 아니라 그냥 문자라는 것을 php에게 알려줘야 한다.

앞에 \을 쓰면 \ 직후에 나타나는 문자를 그 문자가 가지고 있는 문법적인 기능을 무시하고 일반 문자로 처리하도록 약속돼 있다.
\"\"는 문자열 ""가 되는 것이다.
그러므로 href=\"index.php?id=$list[$i]\"라고 쓰고 프로그램을 싱행해 보면 각 항목에 링크가 걸리게 된다.

페이지 소스 결과)

<li><a href="index2.php?id=.">.</a></li>
<li><a href="index2.php?id=..">..</a></li>
<li><a href="index2.php?id=CSS.php">CSS.php</a></li>
<li><a href="index2.php?id=HTML.php">HTML.php</a></li>
<li><a href="index2.php?id=JavaScript.php">JavaScript.php</a></li>
<li><a href="index2.php?id=MYSQL.php">MYSQL.php</a></li>
<li><a href="index2.php?id=PHP.php">PHP.php</a></li>

*반복문과 조건문의 활용3

지금까지 만든 애플리케이션은 상당히 개선됐지만 개선됨과 동시에 여러가지 문제가 발생한다.
소프트웨어를 개발하는 과정은 고된 과정이다.
기능을 추가할 때마다 기존의 여러 가지 문제와 얽히고 설켜 문제가 기하급수적으로 늘어난다.
.과 ..이라는 콘텐츠와는 상관없는 scandir()이 갖고 있는 특성이 노출됐으므로 .과 ..을 어떻게 배제할 것인지 고민하게 된다.
아주 쉬운 방법은 i의 값이 0부터 시작하는데, scandir()은 .과 ..을 맨 먼저 알려준다.
그러므로 i를 2부터 시작하면 쉽게 해결된다.
하지만 scandir()이라는 함수가 꼭 첫 번째로 .과 ..을 준다고 확신하기는 어렵다.
그래서 이곳에서는 괜찮지만 다른 곳에서는 문제가 될 수 있다.
근본적인 해결책을 살펴보면 이렇다.
while문 안에서 현재 항목은 $list[$i]를 통해 알 수 있다.
그 값이 .이나 ..이 아닌경우에 코드가 실행되게 하면 되지 않을까?
이제야 비로소 비교 연산자가 나온다.

$list[$i] == '.';은 무슨 의미인가?
좌항과 우항의 값이 같느냐 다르냐에 따라 true falsle, 즉 불리언이 되는 표현식이다.
원하는 것은 좌항과 우항이 같으냐가 아니냐 다르냐이다.
그때 사용하는 비교 연산자가 !=이다.
!=은 양쪽 항의 값이 다를 때 참이된다.
같으면 false가 된다.
==와 !=은 서로 정반대의 역할을 한다.
만약 $list[$i]의 값이 .과 다른 경우에 아래 코드를 실행하면 되지 않을까?

<?php
	$list = scandir('./data');
	$i = 0;
	while($i<count($list)){
				//data폴더에 있는 모든 값을 배열로 출력 하고 $i와 비교한다. $i가 data파일				의 배열보다 작을 경우
		if($list[$i] != '.'){
				//만약 $list[$i]의 값이 .와 같지 않다면 ture 거짓이면 false이다. 하지만 우리					가 원하는 것은 . .. 을 건너가야하므로 일부로 false값을 주어 i의 값을 상승					시킨다.
		if($list[$i] != '..'){	//위와 같음
			echo "<li><a href=\"index2.php?id=$list[$i]\">$list[$i]</a></li>\n";
				//<li><a href="index2.php?id=CSS.php">CSS.php</a></li>가 소스에 출				력됨
					}
				}
				$i++;
			}

*함수 만들기

함수는 크게 두 가지 측면이 있다.
하나는 내가 만든 함수가 아닌 PHP에서 기본적으로 만들어서 php라는 언어를 쓰는 사람이 쓸 수 있도록 제공하는 함수를 사용하는 것이다.
이것은 지금까지 쭉 해봤을 것이다.
이를테면 scandir(), strlen(), count() 등을 사용했고, 그러한 함수들은 기본적으로 내장된 함수라는 점에서 내장 함수(bulit in function)라고 한다.
지금까지는 내장 함수를 사용하는 방법을 살펴봤다, 그래서 이제부터 함수의 소비자뿐만 아니라 생산자도 되어보겠다.
우선 함수를 배우기 전에 함수를 이용해 우리가 처한 상황을 어떻게 개선할지 살펴보고, 함수의 문법을 배우고 그렇게 배운 함수를 이용해 예제 어플리케이션을 좀 더 수준 높은 어플리케이션으로 만들겠다.

<?php
	if(isset($_GET['id'])){
	}else{
		echo "welcom to php";
	}
?>

이 부분은 웹 페이지에서 제목을 표현하는 코드이다.

하지만 이 줄이 1000줄이라면 무슨 코드인지 파악할 수 있을까? 불가능하다.

함수라는 것을 직접 만들면 선택한 코드에 이름을 부여해서 어떤 기능인지 이름을 부여할 수 있다.
예를 들ㄹ면 print_title();이 실행되면 제목을 만들어내는 코드를 실행하고, print_description();을 실행하면 본문을 만들어내는 코드를 실행한다면 위 함수를 보고 내용은 몰라도 어떤 역할인지 알 수 있다.
그리고 강조된 코드는 print_list()라고 표현할 수 있지 않을까?

그리고 현재 <title> 태그를 비워뒀는데, 현재 본문의 제목과 주소창의 제목이 똑같이 나오게 만들고 싶다면 이미 만들어 놓은 print_title()을 넣으면 된다.

<!DOCTYPE html>
<html lang="ko">
<head>
	<meta charset="utf-8">
	<title>
		<?php
			print_title();
		?>
	</title>
</head>
<body>
	<h1><a href="index.php">WEB</a></h1>
	<ol>
		<?php
			print_list();
			
		?>
	</ol>
	<h2>
		<?php
			print_title();
			
		?>
	</h2>
	<p>
		<?php
			print_description();
		
		?>
	</p>
</body>
</html>


*함수의 형식 1/3

function2.php라는 파일에 코드를 작성해보겠다.

basic() 이라는 함수를 만들었다면 basic();은 이 함수가 실행되는 코드이다.

함수 방식은 JS에서 했던것과 똑같이 하면 된다.

입력값이 있으면 출력값도 있다.
sum()을 자세히 보겠다.
sum()이란 함수는 입력값을 통해 다르게 동작하는 것만으로 아주 혁명적인 변화를 겪었다만 자세히 들여다 보면 두 가지 기능이 있다.
$left와 $right라는 값ㅂ 두 개를 더한다 와 화면에 출력한다 라는 기능 두 가지가 있다.
뭔가를 더하고, 화면에 출력하는 것이 필요하면 sum()이란 함수를 쓰면 편리하겠죠?
하지만 어떤 값을 뭔가를 더하고, 화면에 출력하는 것이 아니라 파일에 저장하고 싶을 수 있따.
또는 이메일로 전송하고 싶을 수 있고, 파일을 업로드하고 싶을 수 있따.
이처럼 여러 가지로 사용할 가능성이 있는데 더하는 기능과 화면에 출력하는 기능을 하나로 퉁쳐버리면 그 기능이 대단히 제한적으로 바뀐다.
그래서 함수를 만들 때 중요한 관점 중 하나는 하나의 함수는 하나의 기능만 담는다라는 관점이다.
물론 답이 있는 문제는 절대 아니다.

함수의 출력값으로 이 문제를 해결해 보겠다.
함수에서는 출력값을 return이라고 한다.
sum2()라는 함수를 만들고 sum2(2,4);라고 실행했을 때 sum2() 자체적으로 결과를 출력하는 기능이 없다.
그 대신 2와 4를 더한 결과인 6이 되는 표현식을 만들고 싶은 것이다.
print(sum2(2,4));를 통해 6을 화면에 출력한다.

그리고 sum이라는 함수안에 $left+$right에 들어가는 2,4는 인자(argument)값이라고 한다.

function부분은 넘어가겠다...

<?php
        function sum($left,$right){
            print($left + $right);
            print("<br>");
        }
        sum(2,3);

        function sum2($left2, $right2){
            $result = $left2 + $right2;
            return $result;
        }
        file_put_contents("result.txt", sum2(2,4));
    ?>

sum2에 있는 $left2, $right2 는 매개변수
$reulst에 매개변수 2개 값을 더하고
반환시킨다.

(sum2(2,4))에 대한 값을 마지막에 해당 폴더에 result.txt라는 파일을 만들어 넣는다.
return문자가 있으면 뒤에 다른 코드가 있어도 다 씹혀먹는다.


함수 자체는 statement(서술,진술)이다.프로그래밍에서는 실행가능한(executable) 최소의 독립적인 코드 조각을 일컫는다. 우리가 프로그래밍을 하면서 컴파일러가 이해하고 실행할 수 있는 모든 구문은 statement다. 문법적으로 해당 언어에 적합한 모든 코드 한 줄이나 블록은 statement라고 할 수 있다. statement는 흔히 한 개 이상의 expression[Expression은 ‘수식’이라는 뜻으로 하나 이상의 값으로 표현(reduce)될 수 있는 코드를 말한다. ]과 프로그래밍 키워드를 포함하는 경우가 많다.


함수를 배운걸 토대로 그전의 내용을 바꿔보겠다.

<!DOCTYPE html>
<html lang="ko">
<head>
	<meta charset="utf-8">
	<title>
		<?php
			print_title();
		?>
	</title>
</head>
<body>
	<h1><a href="index.php">WEB</a></h1>
	<ol>
		<?php
				print_list();
		?>
	</ol>
	<h2>
		<?php
			print_title();
		?>
	</h2>
	<p>
		<?php
			print_description();
		?>
	</p>
	<?php
		function print_title(){
			if(isset($_GET['id'])){
				echo $_GET['id'];
			}else{
				echo 'welcome';
			}
		}
		function print_list(){
			$list = scandir('./data');
			$i = 0;
			while($i < count($list)){
				if($list[$i] != '.'){
					if($list[$i] != '..'){
						echo "<li><a href=\"index.php?id=$list[$i]\">$list[$i]</a></li>";
					}
				}
				$i++;
			}
		}
		function print_description(){
			if(isset($_GET['id'])){
				echo file_get_contents("data/".$_GET['id']);
			}else{
				echo "welcome to PHP";
			}
		}
	?>

함수를 바라보는 첫 번째 시각은 일종의 정리 정돈을 위한 수납상자라고 이해하면 좋다.
물론 함수는 더 다면적이다.

그리고 함수로 정리 정돈을 한다는 것은 현실의 수납상자는 꿈도 못 꿀만큼 엄청난 수납상자라고 할 수 있다.
비유하자면 선반 같은 수납상자를 샀다고 가정해보자
그 크기가 손바닥 만하더라도 63빌딩이 들어갈 수 있다.
현실에서의 수납상자에 물건을 넣으면 그 물건은 하나만 들어간다.
그런데 코드를 함수라는 수납상자에 넣으면 언제든지 꺼내서 마음대로 사용할 수 있다.

*폼과 POST

글을 추가하는 기능을 살펴보자
그전에 해야 할 것이 있다.
사용자의 정보를 서버 쪽으로 전송할 때 사용하는 폼(form)이란 것을 살펴볼 필요가 있다.
먼저 form.html파일을 만든다. (사용자에게 정보를 입력받는 HTML태그)

<body>
    <form action="form.php">
        <input type="text" name="title" placeholder="Title"/>
        <br>
        <br>
        <br>
        <textarea name="content" placeholder="content"></textarea>
        <br>
        <input type="submit" value="전송">
    </form>
</body>

action은 해당 폼의 주소를 어디로 보낼지 결정한다.

name 속성은 서버쪽으로 전달할때 이름을 달아주는 역할을 한다,

현재 상태로 submit=전송 버튼을 누르게 되면

위에 action에 있던 경로로 해당 정보들이 전달된다.

이때 URL파라미터는 $_GET을 통해 받을 수 있다.

$_GET이란 배열임을 뜻한다.

여태까지는 0,1,2와 같은 숫자만 들어가는 배열을 배웠지만 숫자 대신 문자로 값을 가져올 수 있는 배열도 있다.
이 같은 배열을 연관배열(associative array)이라 한다.

form.php에 다음과 같은 코드로 작성한 후 페이지를 새로고침 해보자

<?php
	echo $_GET['title'];
	echo $_GET['content'];
?>

결과)
form.php에 아까 form.html input중 name이 title인 폼이랑 연결돼 출력된다.
content또한 마찬가지

정리해보자면
사용자가<form> 태그 안에 있는 <input>과 관련된 자용자의 정보를 받는 각각의 ui에 값을 입력할 것이다.
그다음 submit 버튼을 누르면 submit 버튼이 속한 <form> 태그의 action속성이 가리키는 URL로 웹 브라우저가 페이지를 바꾼다.
이때<form> 태그에 있는 각 입력값의 name 속성값을 이름으로 써서 URL 뒤에 title은 'php',content는 '내용'이라는 URL을 만들어 전송하는 것이다.

이 맥락에서 <form> 태그는 사요자가 입력한 정보를 URL파라미터로 만들어 내는 것이라고 할 수 있다.
이러한 점에 착안해서 무엇을 할 수 있을까?
PHP에서 파일을 저장하는 함수는 file_put_contents()이다.
그리고 이 함수의 첫 번째 인자로 경로가 들어간다.
두 번째 인자로 description을 지정하면 사용자가 웹 브라우저에서 앞의 주소로 들어갔을 때 PHP가 어떻게 동작할까?
data디렉터리에 PHP라는 파일을 생성할 것이다.

<?php
	file_put_contents('data/' .$_GET['title'], $_GET['content']);s
?>

바로 이런 이유로 데이터를 서버로 전송할 때 URL에 파라미터 정보가 포함되는 방식은 좋은 방식이 아니다.
왜냐하면 사용자들이 이 시스템의 정보가 어떤 것인지 잘 모르니 주소를 복사해서 친구에게 줄 수 있기 때문이다.
친구는 저 주소를 클릭했을 뿐이고 자기가 원하지 않았는데도 글이 작성되는 심각한 문제를 겪을 수 있다.
URL을 통해 form.php에 데이터를 전송하는 방식은 사용자가 서버로 데이터를 보낼 때 혹은 지울 때 쓰면 안된다.
그 대신 글 목록 HTML을 클릭할 때 주소가 나오는데, 누군가를 이 페이지로 오게 하고 싶을 때 127.0.0.1/index.php만 보내도 될까?
안된다.
127.0.0.1/index.php?id=HTML까지 보내야 현재 페이지로 올 수 있다.
즉 URL파라미터를 통해 서버 쪽에 데이터를 전송하는 것은 북마크에서 사용하기에 적합하다.
어떤 콘텐츠는 다른 사람에게 공유할 때 적합한 방식이다.

반대로 앞서 살펴본 것처럼 form.html처럼 URL을 통해 데이터를 서버로 전송하는 방식은 이 주소를 공유했을 때 데이터가 추가되는 문제가 있기 때문에 좋지 않다.
그럼 어떻게 해야 할까?
URL을 쓰지 않고 은밀하게 데이터를 전송해야 한다,
<form>에 데이터를 어떻게 전송할지를 지정하는 method 속성값에 post를 쓰면 된다.

*글 생성

이전 시간에는 폼이 무엇인지 알아봤으니 폼을 예제 애플리케이션에 적용해보겠다
먼저 index.php를 열어보자
welcome이라는 두 번째 제목에 create라는 링크를 추가하자

아까 form.html에 있던 폼을 create.php에 붙이고
form.php는 create_process.php에 붙여서 조합하여 만든다.

생성까지는 완료했지만 여전히 submit버튼을 누르면 흰색 화면만 나오니 사용자 입장에서는 당황스럽다.
어떻게 하면 좋을까?

웹 브라우저의 기능 중에 리다이렉션이라는 기능이 있다,
사용자는 submit 버튼을 통해 create_process.php로 왔따.
이와 마찬가지로 사용자를 다른 페이지로 보내버릴 수 있다.
이를 리다이렉션(redirection)이라 한다.
리다이렉션을 수행하는 php 명령어는 다음과 같다,

header('Location: 이동할 주소');

위 명령어를 이용하면 현재 위치하고 있는 주소(create_process.php)에서 index.php의 id가 $POST['title']에 해당하는 주소로 사용자를 보낼 수 있다.

*글 수정

이번 시간에는 CRUD에서 업데이트(Update), 즉 이미 존재하는 콘텐츠의 내용을 수정하는 방법을 살펴보겠다
update는 언제 기능을 활성화 해야할까?
특정 글을 선택했을 때 update가 나와야 한다.
조건문을 사용하면 된다.

<?php
	if(isset($_GET['id'])) { ?>
		<a href="update.php">Update</a>
	<?php } ?>

update를 클릭했을 때 내용을 수정하려면 수정하려는 내용이 무엇인지 알아야 한다.
마치 그것은 보고자 하는 것이 무엇이냐를 알려면 id 값을 전달해야 하는 것과 같다.
update는 현재 우리가 보고 있는 페이지에 대한 id값을 가져와야 한다.

<a href="update.php?id=<?php echo $_GET['id'];?>">Update</a><!--경로 태그를 추가해준다.(이것만 html태그로 작성)-->
이렇게 되면 id값을 가지고 가는것을 볼 수 있다.

여기서 한가지 팁이 있다면 echo대신 다음과 같이 하면 코드가 더 깔끔해진다.

<a href="update.php?id=<?=$_GET['id'];?>">Update</a><!--경로 태그를 추가해준다.(이것만 html태그로 작성)-->

다음 두 코드가 같다,

<?php echo $_GET['id']; ?>
<?=$_GET['id']; ?>

그럼 update.php를 추가해보겠다.

update.php는 index.php의 내용을 그대로 복사해서 가져온다.

수정 부분)
<?php
		if(isset($_GET['id'])){?><!--만약 url->id안에 값이 있다면
		-->
			<a href="update.php?id=<?=$_GET['id'];?>">Update</a><!--경로 태그를 추가해준다.(이것만 html태그로 작성)-->
		<?php } ?><!--php로 시작했기 때문에 php로 끝나야 한다.-->
	<form action="create_process.php" method="post">
		<p>
			<input type="text" name="title" placeholder="Title" value="<?php print_title() ?>"/>
		</p>
		<p>
			<textarea name="description" style="min-width:700px; min-height:100px"><?php print_description() ?></textarea>
		</p>
		<p>
			<input type="submit" value="만들기"/>
		</p>

이렇게 하면 해당 게시글을 눌렀을때 제목과 내용이 나오는 것을 볼 수 있다.

update는 보다시피 읽기와 쓰기가 모두 필요하며, 앞에서 배운 내용이 총동원됐다.
이제 이 상태에서 submit버튼을 클릭했을 때 이동할 페이지를 지정하겠다.
글을 추가할 때는 create_process.php로 지정했는데, 업데이트 할 때는 update_process.php로 지정하겠다.

<form action="update_process.php" method="post"> // 수정

따라서 update_process.php 파일을 만들었다면 내부적으로 코드를 어떻게 작성해야 할까?
만약 사용자가 HTML이라는 제목을 HTML2로 바꿨다면 어떻게 해야 할까?
data 디렉토리에 있는 HTML이라는 파일명을 HTML2로 바꾸고 그 내용을 기록하면 되지 않을까?
이때 필요한 것은 "파일명을 어떻게 바꿔야 하는가"이다.

검색엔진에서 php file name change를 검색해보자

찾아보면 rename()이라는 것이 있다.

rename ( string $oldname , string $newname [, resource $context ] ) : bool

첫 번째 인자로 oldname이 들어오고 두번째 인자로 새로운 이름을 의미하는 newname이 들어온다.

일단은 update_process.php의 코드를 작성해보자

$_POST['title']을 첫 번째 인자로 하면 될까?
방금 수정한 title 제목은 새로운 이름이지 이전 이름이 아니다.
그래서 $_POST['title']은 두 번째 인자로 들어와야 한다.
왜냐하면 새로운 이름이 두 번째 인자이기 때문이다.
우리가 서버 쪽으로 데이터를 전송할 때 'title'이라는 name으로는 사용자가 수정한 값이 전달되므로 title이라는 값은 수정될 파이렴이고, 이전 파일명에 대한 정보를 따로 서버로 보내야 한다.
이때 사용하기 좋은 태그가 있다.
<input> 태그의 type 속성값 가운데 'hidden'이라는 것이 있다.
그리고 name은 old_title, value는 공백으로 지정하고 페이지를 새로고침 해보자

보다시피 <input> 태그를 추가했는데 아무런 변화가 생기지 않았다.
type이 'hidden'이기 때문이다.
즉, 사용자에게는 노출하지 않으면서 Submit 버튼을 눌렀을 때 action이 가리키는 애플리케이션으로 어떠한 데이터를 전송하고 싶다면 그때 쓸만한 폼 UI가 hidden폼이다.
이 폼의 value 속성값으로 현재의 id값을 주면 된다.

<input type="hidden" name="old_title" value="<?= $_GET['id']?>"/>

update_process.php의 코드는 다음과 같이 수정한다.


<?php
    rename('data/'.$_POST['old_title'], 'data/'.$_POST['title']);
    file_put_contents('data/'.$_POST['title'].'.php', $_POST['description']);
    header('Location:create.php?id='.$_POST['title'].'.php');
?>

*글 삭제

CRUD의 마지막인 D(delete)에 해당하는 삭제 기능을 구현해 보자.
그래서 먼저 index.php에 delete라는 버튼을 만들겠다.
위치는 어디가 좋을까?
수정버튼 밑이 좋지 않을까?
삭제도 현재 보고 있는 글이 있을때, 즉 id 값이 있을 때 활성화 해보도록 하겠다.

그러나 삭제는 수정이나 추가와는 다르게 폼을 거칠 필요가 없다.
delete 버튼을 클릭했을 때 바로 삭제되면 된다.
그래서 href의 값을 다음과 같이 바꾸겠다.
<a href="delete_process.php?id=<?=$_GET['id'];?>">delete</a><!--경로 태그를 추가해준다.(이것만 html태그로 작성)-->

그럼 여기에 나온 delete_process.php를 만들겠다.
그리고 이 안에 들어갈 파일을 삭제하는 php 기능을 검색해보자

검색을 하면 unlink라는걸 찾을 수 있다.

unlink ( string $filename [, resource $context ] ) : bool

보다시피 파일을 삭제하는 기능이라 소개돼 있고 첫 번째 인자로 파일의 이름을 문자열로 넣으라고 돼 있다.

<?php
    unlink('data/'.$_GET['id']);
    header("location:create.php");
?>

결과를 보면 앞서 설명한 대로 이뤄진 것을 확인할 수 있따.
하지만 여기서 끝내면 안된다.

PHP 페이지에서 삭제할 때 delete라 돼 있는데 이것은 아주 나쁜 방법이다.
왜냐하면 delete라는 것은 데이터를 삭제하는 링크인데,
링크를 클릭해서 파일이 삭제된다면 문제가 발생한다.
delete에 해당하는 주소를 친구에서 주었을 때, 친구가 그 링크를 클릭하면 데이터가 삭제돼 버린다.

그리고 예전에 이런 일이 있었다.
어느 회사에서 만든 플러그인이 있었는데, 그 플러그인은 사용자들이 방문하지 않은 페이지들을 실제로 사용자가 방문할 때 빨리 열리도록 링크를 미리 읽어두는 것이였다. 그런데 많은 웹 개발자들이 삭제 기능을 링크로 구현해 두어서 문제가 됐다.
그 플러그인이 삭제 기능에 해당하는 링크를 방문하게 되면 콘텐츠가 삭제되버리는 거다.
글을 업데이트할 때 submit을 get방식으로 하나요? post방식으로 하나요?
post방식으로 한다.
마찬가지로 delete를 클릭했을 때도 뭔가를 삭제한다면 절대로 링크로 하면 안 되고, post방식으로 구현해야 한다.

이를 구현하기 위해 <form>을 만든다.
<form>의 action 값은 delete_process.php를 지정하고 method를 post로 지정한다.
그리고 <input> 태그를 만들고 type을 'hidden'으로 지정한 후 이곳에 id 값을 저장한다.
그리고 Submit 버튼을 만들고 value 값으로 delete를 지정한다.

<form action="delete_process.php" method="post">
	<input type="hidden" name="id" value="<?=$_GET['id']?>"/>
	<input type="submit" value="delete"/>
</form>

delete_process.php 파일의 코드를 다음과 같이 수정한다.

<?php
    unlink('data/'.$_POST['id']);
    header("location:create.php");
?>

post방식으로 보냈으니 post방식으로 받아서 삭제하면 된다.

*파일로 모듈화 - require

이번 시간에는 새로운 기능을 추가하는 것은 아니고, 앞에서 벌려놓은 코드를 좀 더 효율적으로 개선하는 작업을 할 것이다.
이런 것을 리팩터링이라고 한다.
리팩터링은 공장에 재입고시킨다라는 의미가 아닐까..?
기능은 그대로 두고, 내부적인 코드를 훨씬 더 보기좋게, 유지보수하기 편하게, 중복된 코드를 제거하는 과정을 리펙터링이라 한다.
처음부터 이상적인 코드를 짤 수 없기 때문에 리팩터링을 계속해서 반복해나가며, 자신이 짠 코드를 효율적으로 만드는 작업을 끊임없이 해나가야만 애플리케이션이 흉가가 되지 않는다,
그런 것을 리팩터링이라 하고 이 작업은 매우 중요하다.
이번 시간은 기존 코드를 보면서 어떤 문제점이 있는지 확인해보겠다.

index.php와 create.php 코드 상단의 내용을 보면 중복되있는게 많다.
만약 print_title()이라는 것에 어떠한 현상을 추가하면 index.php뿐만 아니라 create.php, update.php까지 꼼꼼히 체크하며 수정해야 하는데 그 과정에서 뭔가를 놓치기 쉽다.
그래서 프로그래밍하는 과정에서 몇차례 말했지만 좋은 코드를 만드는 아주 쉬운 실천 방법은 바로 중복을 제거하는 것이다.

중복을 제거하는 것은 프로그래밍이나 정보기술에서 정말 중요하다.
아주 많은 기술들이 중복의 제거와 관련돼 있다.
다른 말로 정리 정돈과 관련 있다고 할 수 있다.
그래서 여기서는 코드의 중복을 제거해보겠다.
프로그램에서 재사용할 만한 코드나 로직을 잘 정리 정돈해 놓으면 그것을 도서관이라고 표현한다.
도서관이란 무엇인가?
꺼내보기 쉽게 책을 정리 정돈하는 것이다.
코드를 나중에 재사용하기 좋도록 잘 정리 정돈한 것도 도서관이라고 한다.
도서관을 영어로 하면 라이브러리(library)인데 이름을 다 쓰면 길기 때문에 lib이라는 이름의 디렉터리를 만들고 재사용 가능성이 있는 것들을 이곳에 잘 정리 정돈해 두었다.
print.php라는 파일을 만들어서 lib디렉터리 밑에 두겠다.

print.php에 메인에 있던 함수를 집어넣는다.

 <!-- 함수 부분 -->
 <?php
        function review_main_title(){
            if(isset($_GET['id'])){
                echo $_GET['id'];
            }else{
                echo "리뷰 홈페이지";
            }
        }
        function review_list(){
            $list=scandir('./reviewData');
            $i=0;
            while($i < count($list)){
            if($list[$i] != '.'){
                if($list[$i] != '..'){
                    echo "<li><a href=\"r_update.php?id=$list[$i]\">$list[$i]</a></li>";
                }
            }
            $i++;
            }
        }
        function review_list_title(){
            if(isset($_GET['id'])){
                echo $_GET['id'];
            }else{
                echo "리스트를 클릭해주세요";
            }
        }
        function review_list_contents(){
            if(isset($_GET['id'])){
                echo file_get_contents('reviewData/'.$_GET['id'].'.php');
            }else{
                echo "Review페이지에 온걸 환영합니다.";
            }
        }
    ?>
    <!-- 함수 부분 끝 -->

그리고 본문내용 상단에

<?php
	require('lib/print.php');
?>

를 추가한다.

위 코드의 의미는 'PHP야 본문.php는 lib 밑에 있는 print.php코드들을 필요로 해.'라는 뜻이다.
그리고 본문.php의 이 코드ㅐ를 create.php와 update.php에도 가져다 놓으면 index.php, create.php, update.php에서 모두 print.php를 가져다 쓰고 있기 때문에 print.php파일에서 Welcome 부분을 바꾸거나 수정하면 모든 페이지가 동시에 바뀌는 폭발적인 효과가 일어난다.

이제 나머지 중복으로 들어가는 create update본문 부분에도 추가해주면 된다.

함수와 require()를 통해 php 코드를 꺼내는 점이 굉장히 비슷하다.
왜냐하면 본질적으로 같은 행위이기 때문이다.
그리고 중복을 끝까지 추적한다고 했다.
즉, 본문.php와 update를 보면 어느 부분이 중복돼 있는지 또한 볼 수 있다.

보통 재사용할 수 있는 로직들을 라이브러리화한다.
이처럼 보여지는 것과 관련된 코드는 라이브러리화하기 보다는 별도로 빼는 경향이 있다.

그래서 상단부분 </ol>까지 잘라서 view.php 라이브러리 파일을 만들고 </body></html>가 모든 페이지에서 똑같이 반복되므로 view디렉터리 아래에 bottom.php라는 파일을 만들고 이곳으로 중복되는 코드를 옮기겠다.

흔히 jsp에서 include file을 통해 header와 footer를 나누는 작업이라 보면된다.

*require(), require_once()

require() 함수는 함수를 참조한다 보면된다

*require_once() 함수

require()함수를 쓰다가 경로가 중복되는 경우가 생기면 오류가 생긴다.

하지만 require_once()를 쓰게 되면 중복으로 들어가는 부분은 무시하고 하나만 적용하게 된다.

* htmlspecialchars() 함수

문장 내에 HTML 코드가 들어가는 특수 문자를 포함시켜 입력한 후 화면으로 출력할 때 그 HTML 특수 문자가 HTML 태그로 적용되어 출력되는 것이 아니라, HTML 특수 문자가 일반 문자로 인식되어 그대로 출력되도록 해준다.

예)

만약 내가 content부분에 <script>alert();</script>를 사용하게 되면 내용본문이 안뜨고 알람창이 뜨게 되는데 이것을 htmlspecialchars()로 감싸게 되면

내용 본문에 <script>alert();</script>가 텍스트로 출력된다.

*strip_tags()

strip_tags는 문자열에서 HTML 태그와 PHP 태그를 제거하는 함수이다.

사용 예)

echo strip_tags(string $var,"<tagname>[남길 태그]");

echo strip_tags(<p>안녕하세요 <a href=\"#\">우정호입니다.</a></p>, <p>);

이렇게 되면 <p>태그를 제외한 a 태그는 사라진다.

유용하게 쓰일거면 <img>태그같은 것들만 살려두는게 좋다.

*basename()

순수 파일 이름만 반환하는 함수

예)
basename($test, option value)

위와 같이 첫번째 인자는 순수 파일명만 가져올 변수를 설정하고 두번째 인자는 선택사항이다.
선택사항에 특정 확장자를 넣을 경우 해당하는 확장자 역시 보여주지 안헥 된다.
즉 확장자 명도 삭제되는 것이다.

 사용 예)
<?php
   $pathName = '/uploadfile/sampleimage.jpg';
   $modName = basement($pathName);

   echo $modName;
   // 함수를 적용하여 이름만 출력
?>

결과 )
smapleimage.jpg

확장자를 삭제하는법)

<?php
   $pathName = '/uploadfile/sameimage.jpg';
   $modName = basement($pathName, '.jpg');
   // 두번째 매개변수를 입력함

   $echo modName;
?>

*UI vs API

UI는 User Interface의 약자이다.
API는 Application Programming Interface의 약자이다.
이 단어들은 인터페이스라는 공통점과 사용자와 애플리케이션 프로그래밍이라는 차이점만 가지고 있다.

먼저 UI라는 것은 무엇일까?
애플리케이션이 있다면 이 애플리케이션을 사용하는 사람들이 접하게 되는 모든 것이 UI이다.
링크라던지 폼이라던지, 또는 시각적으로 눈에 보이는 텍스트가 UI에 해당한다.
사용자는 UI를 통해 시스템을 조작하고 시스템이 제공하는 정보를 볼 수 있다.

그럼 API는 무엇일까?
우리가 애플리케이션을 만들 때 모든 것을 처음부터 끝까지 만들까?
그렇지 않다.
인간은 신이 아니다.
링크를 만들기 위해서는 웹 브라우저의 <a>태그를 호출해야만 링크를 만들 수 있다.
또 어떤 특정 디렉터리의 파일 목록을 알기 위해서는 PHP가 제공하는 scandir()을 호출해야 파일 목록이 담긴 배열을 받을 수 있다.
이때 웹 브라우저의 <a>태그, PHP의 scandir()과 같은 함수를 API라 할 수 있다.
즉, 애플리케이션을 만든다는 것은 컴퓨터 언어의 문법에 따라 기반이 되는 시스템(여기서는 웹 브라우저나 PHP가 해당한다)이 제공하는 API를 호출하는 것이라고 할 수 있다.

API가 부품이라면 언어의 문법은 그 부품을 결합해서 새로운 기능을 만들어 내는 결합 방법이라고 할 수 있다.
API가 무엇인지 알았으니 이제 어떻게 공부하면 좋을지 생각해보자.

----------------------------------------------------------------------------------------------------

파일의 좋은 점과 나쁜 점이 있는데, 좋은 점은 아주 쉽다는 것이다.
파일은 그냥 읽고 쓰는 방법만 알면 쓸 수 있기 때문이다.
파일의 나쁜 점은 사실 나쁜 점이라기보다는 파일의 대체재가 갖고 있는 장점이 너무 크기 때문에 파일의 나쁜 점이 된다.
파일의 대체재는 데이터베이스이다.
데이터베이스도 내부적으로 파일을 쓰지만 어쨋든 데이터베이스라는 소프트웨어는 훨씬 더 데이터를 체계적이고 안전하고 빠르게 관리할 수 있다.

예를 들어 data라는 디렉터리가 1억 개의 파일이 있고, 이곳에서 PHP라는 텍스트를 검색하고 싶다면 아마 여러분은 PHP의 반복문을 이용해 파일을 하나씩 열어서 그 안에 텍스트가 있는지 조사해야 할 것이다.
그런데 만약 파일이 1억 개라면 파일 하나를 처리하는데 0.1초가 걸린다고 하면 총 150일이 걸린다.
0.01초라 해도 15일이 걸리는데 이를 어디에 쓸까?
그래서 성능을 높이기 위해서는 검색할 때 모든 파일을 검색하는 방법으로는 한계가 있다.
그 대신 정보가 생성될 때마다 사용자들이 검색할 만한 정보의 위치를 미리 어딘가에 적어두는 방법이 있다.
이런 식으로 처리할 수 있지만 이렇게 하기란 굉장히 탁월한 엔지니어에게도 어려운 일이 될 수도 있다.
이를 위해 일군의 천재적인 소프트웨어 엔지니어들이 데이터베이스라는 소프트웨어를 만들었다.
(데이터베이스는 특정 제품명이 아니라 제품군이다.)
...생략

웹 브라우저 -> 웹 서버 -> php 서버 -> mysql 서버
다시 역순으로 보여준다.

일단 준비과정으로 index.php를 만든다.

<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PHP와 MYSQL서버 연동</title>
</head>
<body>
    <h1>WEB</h1>
    <ol>
        <li>HTML</li>
    </ol>
    <h2>Welcome</h2>
    Lorem ipsum dolor sit amet, consectertur adipisicing elit,
</body>
</html>


그다음 DB를 만들어준다.

일단 테이블을 보관할 데이터 베이스, 다른 말로 스키마를 만들어 보자
MYSQL에서 다음 명령을 실행한다.

CREATE DATABASE opentutorials;

그러면 데이터 베이스가 생긴다.

SHOW DATABASES;

데이터 베이스가 생선된 것을 확인했으면 다음 명령어를 이용해 사용할 데이터 베이스를 opentutorials로 변경한다.

USE opentutorials;

이제 예제 웹 애플리케이션의 데이터를 저장할 수 있는 표를 만들어 보겠다.
표의 이름으로 'topic'을 지정하겠다.

여기서는 id 값과 제목(title), 본문(description), 글의 생성 시각(created)이 포함된 표를 만들겠다.
title은 텍스트 description은 긴 텍스트, created는 날짜/시간을 나타내는 datetime이라는 데이터 타입으로 표현할 것이며 id 값은 각 행을 식별하기 위한 식별자이기 때문에 행이 추가될 때마다 자동으로 숫자가 1씩 증가되게 할 것이다.
이 내용을 토대로 다음과 같은 명령으로 테이블을 만든다.

CREATE TABLE topic(
	id int(11) NOT NULL AUTO_INCREMENT,
	title varchar(45) NOT NULL,
	description text,
	created datetime NOT NULL,
	PRIMARY KEY(id)
)ENGINE = InnoDB;

id값은 정수이고 11글자까지 보여주겠다는 뜻이다.
id 값은 식별자이기 때문에 없으면 안된다는 의미에서 NOT NULL을 지정했고,
행을 추가할 때 특별히 id 값을 insert 문에 언급하지 않으면 저동으로 값이 1씩 증가하도록 AUTO_INCREMENT를 지정한다.
다음으로 제목(title)은 끝없이 길어질 정보는 아니기에 45자 정도로 지정한다.
제목 또한 있어야 하므로 NOT NULL을 지정한다.
본문(description)에는 아주 긴 텍스트가 들어올 수 있으니 text로, 다음으로 생성일은 날짜 시간을 지정하는 것이 적절하므로 datetime이라는 데이터 타입을 쓸 것이며 비워둘 필요가 없으므로 NOT NULL을 지정한다.
그 다음 주키(primary key)를 id로 지정한다.

주키가 되면 두가지 장점을 갖게 된다.
첫 번째로 똑같은 id 값을 가지고 있는 행이 추가되려고 하면 데이터베이스가 이를 거절하게 된다.
그렇기에 중복되지 않음을 보장할 수 있다.
데이터 베이스틑 내부적으로 색인이라는 것을 만들고 색인 중에서도 가장 강력한 색인을 걸기 때문에 id 값을 기반으로 데이터를 가져올 때 순식간에 가져올 수 있게 된다.
이것은 다른 MySQL 수업에서도 언급하지 않았기 때문에 이 정도로만 알고 있어도 된다.

그다음 내용은 지정해도 되고 지정하지 않아도 되지만, 여기서는 지정하고 넘어가겠다.
즉, ENGINE=InnoDB에서 InnoDB가 무엇인지 설명하겠다.
MySQL의 가장 핵심적인 부분은 교체 가능하다.
그 핵심적인 것이 무엇인지 설명하는 것은 조금 어려운 이야기지만 그러한 핵심적인 부분은 여러 종류가 있다.
그중 하나가 InnoDB이다.
InnoDB가 기본값이기 때문에 InnoDB를 안써도 InnoDB가 지정될 것이다.

그럼 테이블이 잘 만들어 졌는지 확인해보자

SHOW TABLES;

그럼 아래 명령으로 이 테이블의 구조를 보자

DESC topic;

*MySQL API 찾기

지금부터 PHP와 MySQL을 연동하는 구체적인 방법을 살펴보자.
우선 검색엔진에서 검색을 해보겠다.
검색 엔진에서 'php mysql api'를 검색하면 php를 이용해 MySQL에 접속하는 애플리케이션 프로그래밍 인터페이스를 검색할 수 있다.
그럼 어떤 API를 선택할 것인가를 다룬 페이지가 나온다.

https://www.php.net/manual/en/mysqlinfo.api.choosing.php

보다시피 mysqli,PDO,mysql이라는 세가지 방식이 있다.
그리고 이 페이지에서는 mysqli와 PDO_MySQL API를 추천하고 mysql은 더 이상 추천하지 않는다고 나와있따.
그리고 하단부를 보면 각 API를 비교해서 보여주는 내용이 있다.

가장 좋은 방법은 PDO_MySQL을 사용하는 것이다.
이것을 사용하면 MySQL 말고 다른 관계형 데이터 베이스, 즉 오라클이나 MS-SQL 등을 쓸 때 PHP코드를 바꾸지 않고도 데이터 베이스를 교체할 수 있다는 장점이 있다.
하지만 PDO라는 방식은 객체라는 것을 사용하는데, 이전의 PHP수업에서는 객체를 의도적으로 다루지 않았기 때문에 이 방식 말고 mysqli라는 방식을 이용해 수업을 진행하겠다.
이 방식도 추천되는 방식이라 문제될 것이 없지만 장기적으로 예제 애플리케이션이 사용할 데이터베이스가 MySQL이 아니라 오라클 등의 데이터베이스로 교체될 가능성이 있다면 PDO라는 방식도 고려해보길 바란다.
아무튼 여서는 Mysql를 이용해 수업을 진행하겠다.
검색창에 php mysqli api를 검색해보자

https://www.php.net/manual/en/book.mysqli

위 화면은 mysqli의 사용 설명서인데, 제목을 보면 improved라고 적혀 있다.
improved는 '개선된'이란 뜻이고, mysqli에서 i가 improved를 의미한다는 것을 알 수 있다.
이 페이지에서는 많은 것을 볼 수 있는데 'Quick start guide' 부분의 Dual procedural and object-oriented interface'라는 링크를 클릭해 보면 다음과 같은 내용을 볼 수 있다.

<?php
$mysqli = mysqli_connect("example.com", "user", "password", "database");
$res = mysqli_query($mysqli, "SELECT 'Please, do not use ' AS _msg FROM DUAL");
$row = mysqli_fetch_assoc($res);
echo $row['_msg'];

$mysql = mysql_connect("example.com", "user", "password");
mysql_select_db("test");
$res = mysql_query("SELECT 'the mysql extension for new developments.' AS _msg FROM DUAL", $mysql);
$row = mysql_fetch_assoc($res);
echo $row['_msg'];
?>


*mysqli_connect

지금부터 mysqli라는 API를 이용해 PHP에서 데이터 베이스에 접속 하는 방법을 살펴보겠다.
mysqli  사용 설명서의 'Dual procedural and object-oriented interface 부분을 통해 함수 방식으로 mysqli를 제어하는 방법의 예제를 살펴보겠다.

예제를 실행할 곳에 insert.php라는 파일을 생성한다.
그리고 위에서 강조한 코드를 붙여넣겠다.
이 코드를 직접 사용하지는 않을 테지만 참고하기 위해 주석으로 처리하고 함께 예제를 완성해 나가겠다.
<?php
    // $mysql = mysqli_connect("example.com", "user", "password", "database");
    // $res = mysqli_query($mysql, "SELECT 'please, do not use' AS _msg FROM DU-AL");
    // $row = mysqli_fetch_assoc($res);
    // echo $row['_msg'];
?>

한쪽에는 웹 브라우저를 열어두고, MySQL 모니터를 사용할 때처럼 다음과 같은 명령을 입력한다.

./mysql -uroot -p -hlocalhost

여기서 -p는 패스워드를 입력하겠다는 뜻이다.
localhost는 127.0.0.1과 같은 뜻이며, 둘 다 자기 자신의 컴퓨터를 가리키는 아주 특수한 도메인과 ip 주소이다.
위와 같이 입력하고 엔터 키를 치고 비밀번호를 입력하면 Mysql서버에 접속된다.
지금부터 내리는 명령들은 로그인한 root라는 사용자의 권한에 따라 명령이 데이터베이스 서버에 전송되는 것이다.
PHP 도 마찬가지로 MySQL 서버에 대해서는 클라이언트로 동작할 것이기 때문에 인증을 맨 먼저 해야 한다.
예제를 보고 하나씩 입력할 테니 똑같이 따라 하면 된다.

mysqli_connect()

connect는 접속한다는 뜻이다.
위와 같은 함수가 있는데, 사실 이 함수가 어떻게 생겼는지는 저도 모릅니다.
이 함수는 이러이러한 입력값을 가지고 있고, 그 입력값에 따라 이 함수를 호출하면 데이터베이스 서버에 PHP가 접속할 것이라는 말을 믿고 따라 하는 것이다.
mysqli_connet() 라는 함수의 사용 설명서를 살펴보겠다.
앞서 본 문서의 하단에 여러 가지 mysqli의 API 목록이 나온다.
이 중에서 mysqli_connet()와 직접 관련된 것은 없지만 __construct()를 클릭해 보자

만약 객체지향 방식으로 코드를 작성한다면 __construct 같은 형태로 호출해야 하고, 함수 방식으로 mysqli를 쓰겠다면 mysqli_connect라는 것을 사용하면 된다고 나와있다.
상세 설명에서 함수 방식을 의미하는 'Procedural style'을 보면 된다.

public mysqli::__construct ([ string $host = ini_get("mysqli.default_host") [, string $username = ini_get("mysqli.default_user") [, string $passwd = ini_get("mysqli.default_pw") [, string $dbname = "" [, int $port = ini_get("mysqli.default_port") [, string $socket = ini_get("mysqli.default_socket") ]]]]]] )

대괄호는 생략 가능하다는 것을 의미하며, 첫 번째 자리에는 호스트가 들어온다고 돼 있다.
호스트로는 데이터베이스 서버의 주소를 적는다.

mysqli_connect("localhost");

지금 제가 사용하고 있는 환경과 같이 PHP와 데이터베이스가 같은 서버, 같은 컴퓨터에 있다면 localhost 또는 127.0.0.1을 쓰면 된다.
만약 다른 주소에 있다면 MySQL 서버가 설치돼 있는 컴퓨터의 도메인이나 IP주솔를 입력하면 된다.

그럼 두 번째 자리에는 무엇이 들어오는지 볼까요? 두번째 자리에는 $username이 들어온다.
이것은 -uroot와 같은 것이다.

mysqli_connect("localhost", "root");

그 다음 자리는 패스워드이다. 각자 자신의 패스워드를 쓰면 된다.

mysqli_connect("localhost", "root", "111111");
비밀번호는 코드나 이런식으로 작성하는 방법은 아주 좋지 않다...

마지막으로는 데이터 베이스 이름이 들어오면 된다.

mysqli_connect("localhost", "root", "111111", "opentutorials");

완성된 코드는 다음과 같다.

<?php
    // $mysql = mysqli_connect("example.com", "user", "password", "database");
    // $res = mysqli_query($mysql, "SELECT 'please, do not use' AS _msg FROM DU-AL");
    // $row = mysqli_fetch_assoc($res);
    // echo $row['_msg'];
    mysqli_connect("127.0.0.1", "root", "autoset", "myDB");

?>

MySQL 모니터로 봐서는 opentutorials라는 데이터베이스 또는 스키마가 사용된다.
위 코드가 실행되면 데이터베이스 서버 접속에 해당하는 작업이 시작된다.

*mysqli_query

이번 시간에는 데이터베이스에 데이터를 추가하는 작업을 시작해 보겠다.

예제에서 "SELECT 'please, do not use' AS _msg FROM DU-AL"은 무엇인가?
SQL 문이다.
여기서 SQL 문을 전달할 때는 mysqli_query 라는 API를 사용해야 한다는 사실을 추정할 수 있다.
그럼 검색 엔진에서 'mysqli_query'를 검색해보자

mysqli_query ( mysqli $link , string $query [, int $resultmode = MYSQLI_STORE_RESULT ] ) : mixed

PHP 공식 메뉴얼을 보니 절차식 형식, 즉 함수 방식의 mysqli_query 에는 첫 번째 인자로 $link라는 값이 들어온다고 돼 있다.
두 번째 인자로 쿼리가 들어오며 문자열 형식으로 돼 있다.
첫 번째 인자로 mysqli가 왔고 이것은 mysqli_connect()의 결과이다.

$conn = mysqli_connect("127.0.0.1", "root", "autoset", "myDB");
mysqli_query($conn," ");   

mysqli_query의 첫 번째 자리에 $conn을 지정하고 두 번째 자리에 SQL문을 지정하면 PHP가 클라이언트 되어 데이터 베이스 서버를 대상으로 어떤 SQL문을 실행할 수 있다.

위 코드를 한번 실행해보겠다.
한쪽에서는 index.php웹 페이지를 열고, 다른 한 쪽에서는 MySQL에 어떤 명령어가 전달되는 보여주는 제네럴 로그를 열어뒀다.

그리고 마지막으로 해당 문장을 추가해주고 확인해보자

<?php
    // $mysql = mysqli_connect("example.com", "user", "password", "database");
    // $res = mysqli_query($mysql, "SELECT 'please, do not use' AS _msg FROM DU-AL");
    // $row = mysqli_fetch_assoc($res);
    // echo $row['_msg'];
    $conn = mysqli_connect("127.0.0.1", "root", "autoset", "myDB");
    mysqli_query($conn,"
        INSERT INTO topic(
            title,
            description,
            created
            )
            VALUES(
                'MYSQL',
                'MYSQL is ....',
                NOW()
                
    )");    
        
?>

데이터베이스를 확인해보면 해당 값이 들어간걸 확인할 수 있을것이다.

* mysqli_error

코딩을 하다 보면 자연스럽게 여러 가지 실수가 생긴다.
사람이 하는 실수도 있고, 시스템의 실수도 있을 수 있다.
그래서 실수는 할 수 있는데, 그 실수를 해결하는 것이 중요하다.
이때, 문제에 최대한 가까이 가면 사실 그 문제는 해결한 것과 다름없다.
이번 장에서는 문제에 최대한 가까이 다가가기 위한 여러 가지 팁을 살펴보겠다.

기존 코드에서는 SQL 문을 API로 바로 전달했는데, 이를 변수에 담은 다음 전달해 보겠다.

<?php
$conn = mysqli_connect("127.0.0.1", "root", "autoset", "myDB");

$sql = "
            INSERT INTO topic(
            title,
            description,
            created
            ) VALUES(
            'Mysql',
            'Mysql is....',
            NOW()
            )";
    mysqli_query($conn,$sql);

?>

이렇게 하면 중간에 문제가 생겼을 때, echo $sql 문을 이용해 간편하게 테스트 해 볼 수 있다는 장점이 있다.
다음과 같이 잘못된 SQL문을 만든 다음 테스트해보겠다.

PHP는 기본적으로 문제가 생겼을 때 어디에 문제가 있는지 알려주지 않는다.

따라서 웹 브라우저에 출력된 SQL문을 복사해서 MySQL 모니터에 붙여 넣은 다음에 실행해 보면 에러가 발생하는 것을 볼 수 있다.
이 에러를 참고하면 어디에 문제가 생겼는지 찾아볼 수 있다.

MySQL 모니터가 에러를 알려준 것처럼 우리도 에러를 알아낼 수 있으면 좋지 않을까?
검색을 통해 알아 보겠다.
검색 엔진에서 how to get error in php mysqli로 검색해 검색 결과를 클릭해 보겠다.

mysqli_error 제목을 보고 에러와 관련돼 있다고 추론해 볼 수 있다.
함수형 방식을 보면 mysqli_error()의 인자로 link 값을 주는데, link 값이 무엇인지 살펴봤더니 mysqli_connect()를 통해서 반환된 결과라고 나와있다.
이를 참고해서 코드를 작성해 보자

echo mysqli_error($conn);

결과)

INERT INTO topic( title, description, created ) VALUES( 'Mysql', 'Mysql is....', NOW() )You have an error in your SQL syntax; check the manual that corresponds to your MariaDB server version for the right syntax to use near 'INERT INTO topic( title, description, cre' at line 1

어떤 에러가 있는지 데이터베이스 서버가 알려준 정보를 PHP가 출력해주는 모습을 볼 수 있다.
즉, mysqli_error()를 통하면 어떤 에러가 발생했을 때 그 에러가 어떤 에러인지에 대한 데이터베이스 서버의 진술을 들을 수 있다.

mysqli_error() 예제는 우리가 조금 음미할 만한 것들이 있으니 조금 더 살펴보자.
아래에서 강조한 부분을 보면 mysql_query(), 즉 쿼리문을 서버로 전송하는 API에서 에러가 발생하는 상황이 조건문으로 묶여 있다.
무슨 뜻일까..? [!$mysqli->query("SET a=1")]

<?php
$mysqli = new mysqli("localhost", "my_user", "my_password", "world");

/* check connection */
if ($mysqli->connect_errno) {
    printf("Connect failed: %s\n", $mysqli->connect_error);
    exit();
}

if (!$mysqli->query("SET a=1")) {
    printf("Error message: %s\n", $mysqli->error);
}

/* close connection */
$mysqli->close();
?>

다시 mysqli_query()의 사용 설명서를 살펴보겠다.
mysqli_query()의 리턴값을 보니 실패했을때 리턴값이 false가 되는 특성을 가지고 있다.
또한 SELECT, SHOW, DESCRIBE와 같이 정보를 읽는 것과 관련된 쿼리를 실행했을 때는 mysqli_result라는 아직은 이해할 수 없는 미지의 객체가 전달되고, 그 외의 INSERT, UPDATE, DELETE와 같은 쿼리에 성공했을 때는 리턴값이 true라고 돼 있다.
따라서 mysqli_query() 리턴값의 특성을 이용하면 어떤 명령을 실행했을 때 성공했는지 실패했는지 확인할 수 있다.

이를 코드에 적용해 보겠다.

$result = mysqli_query($conn,$sql);
    if($result == false)
    echo mysqli_error($conn);// mysqli_error() 에러를 html화면상 볼 수 있는 메소드

mysqli_query()는 오류가 없으면 true 오류가 있으면 false이기때문에 if mysqli_query($conn,$sql) 가 false일때 에러문을 출력하라고 나와있다.

mysqli_query()의 결과를 $result로 받고, $result가 flase일 때 mysqli_error()를 실행한다거나, 사용자에게 문제가 발생했다고 통지한다거나, 어떤 문제가 발생했는지 로그 파일로 저장하는 등의 처리를 할 수 있다.

그리고 한 가지 더 말하자면 mysqli_error()를 echo를 이용해 출력하고 있는데, 절대로 이렇게 하면 안된다.
개발할 때는 이렇게 해도 되겠지만, 실제로 사용자를 받는 상황에서 이렇게 하면 사용자중에 나쁜 사람이 있을 수도 있기 때문에 위험할 수 있다.

따라서 위와 같은 메세지를 노출해버리면 공격자가 이 시스템에는 topic이라는 테이블이 있고, title, description, created라는 칼럼을 가지고 있다는 굉장히 중요한 정보를 얻을 수 있다.
이러한 정보를 종합적으로, 입체적으로 재구성해보면 공격할 수 있는 공략 방법이 노출될 수 있기 때문에 내부적인 시스템 상황은 될 수 있으면 외부에 노출시키지 않아야 한다.
따라서 이러한 방법은 개발할 때만 용납되고, 실제 운영되는 서버에서는 절대로 하면 안된다.

다시 설명서를 살펴보니 mysqli_connect_error()라고 하는 별도의 함수가 존재하는 것을 알 수 있다.
위에 주석으로 check connection이라고 돼 있는 걸 보니 데이터베이스 서버에 접속하는 과정에서 발생하는 에러는 mysqli_connect_error() 함수를 통해 알 수 있다는 것을 알 수 있다.

이러한 것들을 이용해 나중에 애플리케이션을 개발할 때 안전하게, 또 문제가 발생했을 때 빠르게 알 수 있었으면 좋겠다.
여기까지가 insert라고 하는 대단원의 마지막이고, 지금까지 데이터 서버에 insert하는 과정에서 에러를 찾는 방법 그리고 데이터베이스 서버에 접속하는 방법을 살펴봤다.

*활용 - 글 생성

지금까지 MySQL과 PHP를 연동하는 방법으로 PHP의 API인 mysqli라고 하는 부품의 사용법을 요모조모 따져봤다.
뭔가를 배웠다면 배운 것을 써먹어야 한다.
지금부터 앞에서 배운 것을 써먹어 보겠다.


데이터 베이스에 데이터 집어넣기

<?php
    // var_dump($_POST);
    $conn = mysqli_connect('localhost','root','autoset','mydb');
    //첫번째 인자는 데이터 서버의 주소, 두번째 인자는 데이터 베이스 사용자, 세번째는 데이터 베이스 사용자 비밀번호, 네번째는 데이터베이스 이름
    $sql = "
        INSERT INTO topic
        (title, description, created)
        VALUES(
            '{$_POST['title']}',
            '{$_POST['description']}',
            NOW())";
    // $sql 변수에다가 쿼리문을 담는다. 토픽이라는 데이터 베이스 안에 title(제목), description(본문), created(시간)
    //values = 포스트로 받은 title, description 그리고 마지막 현재시간을 나타내는 now()
    // echo $sql;
    $result = mysqli_query($conn,$sql);
    //제대로 들어가게 되면 true반환을 오류가 있으면 false를 나타내고 $result값에 저장한다.
    if($result == false){
        //만약 $result 변수에 false 값이 들어간다면
        echo '저장하는 과정에서 문제가 생겼습니다.';
        //쿼리문에 어떤 오류가 났는지 알려주는 구문을 적는다.
        error_log(mysqli_error($conn));
        //C:\AutoSet10\server\logs 이곳에 에러를 기록해둔다.
    }else{
        echo '<script>alert("성공했습니다.");</script>';
        header('Location:index.php');
    }
    // echo $sql;
    /*
        데이터베이스 접속, 데이터베이스 선택, mysqli_query를 통해 쿼리를 실행하는 것까지가 하나의 세트이다.
        다시 process_create.php로 와서 다음과 같이 코드를 작성한다.
    */
?>

*SELECT 사용법 1

지금부터는 데이터 베이스에서 읽어보는 방법을 살펴보겠다.
위 화면에서 보다시피 글 목록이 나오고 본문이 나오게 하려면 그 데이터를 가져와야 한다.

SQL문 중에서 데이터 읽기와 관련된 SQL 문은 select이다.
따라서 이번 시간의 주인공은 select가 될 것이다.

예제의 API단계에서 select를 깔끔하게 체크하기 위해 index.php를 건드리지 않고 select.php라는 파일을 만들었다.
select를 사용하는 경우에도 당연히 데이터베이스 서버에 접속해야 하기 때문에 데이터베이스 접속을 수행하여야 한다.
이 부분은 insert.php나 process_create.php에서 이미 했기 때문에 그대로 복사해서 select.php에 붙여넣겠다.(이제부터 데이터베이스 연결에 대해서는 더이상 언급하지 않겠다.)

<?php
    $conn = mysqli_connet('locahost','root','autoset','mydb');
?>

그 다음에 글 목록을 가져와야 하는데, 그러기 위해서는 데이터가 먼저 입력돼 있어야 한다.
입력한 웹을 통해 create.php 페이지에서 할 수 있다.
다음과 같이 데이터를 추가해주자

총 4개의 데이터를 생성

이제 이 데이터를 select.php라는 페이지에서 출력해 보겠다.
데이터 베이스 서버에게 select 문을 전송해야 하므로 select 문을 먼저 만들어보겠다.

$sql = "SELECT * FROM topic";

여기서 한 가지 언급할 부분이 있다.
select 문에서 가장 위험한 요소는 모든 데이터를 가져오는 것이라는 점이다.
데이터가 1억 건이면 문제가 생긴다.
항상 몇 개의 데이터를 가져올지 제약을 걸어야 한다.
따라서 1000이라 지정하면 실제로 10,000개나 1억 개라도 1000개 이상 가져오지 않으니 애플리케이션이 좀 더 안전해 진다.
하지만 불필요하게 쿼리의 복잡도를 높이기 때문에 여기서는 언급만 하겠다.
이제 쿼리를 생성하는 것까지 했으니 쿼리를 데이터베이스 서버에 전송해야 한다.

그럼 쿼리의 결과를 $result 변수에 담았는데, 데이터를 실제로 가져오려면 $result 변수를 이용하면 되겠죠? 먼저 var_dump()를 이용해 $result에 무엇이 들어있는지 확인해 보겠다.

var_dump()로 $result 확인

object(mysqli_result)#2 (5) { ["current_field"]=> int(0) ["field_count"]=> int(4) ["lengths"]=> NULL ["num_rows"]=> int(4) ["type"]=> int(0) }

mysqli_result라는 것을 받았다.
지금 당장은 문법적으로 이해되지 않을 수도 있지만, mysqli_result는 '객체'라는 것이다.
여기에는 여러 가지 정보가 담겨 있으며, num_result안에 topic 테이블의 행이 담겨 있지는 않고 우리가 예상한 것과 다른 것을 확인했으니 이제 무엇을 해봐야 할까?
mysqli_query가 어떤 속성을 가지고 있는지 확인해 봐야겠다.
검색 엔진에서 'mysql_query로 검색해보자

https://www.php.net/manual/en/function.mysql-query.php

위와 같은 공식 PHP문서에서 'Return Values'를 보니 mysqli_query()가 실패했을때는 false를 반환하는 것을 볼 수 있고, SELECT, SHOW DESCRIBE처럼 읽기와 관련된 SQL을 실행했을 때는 mysqli_query()의 리턴값으로 mysqli_result라는 객체를 반환한다고 적혀있다.
여러 복잡한 정보들이 들어 있지만 앞에서 살펴본 $num,rows가 있고 $field_count도 있다.
이를 클릭해서 확인해 보면 'Gets the number of rows in a result', 즉 결과의 개수를 보여준다는 것을 알 수 있다.
만약 여러분이 결과의 개수가 필요하다면 다음과 같이 작성해서 확인할 수 있다.
var_dump($result->num_rows);

결과)

int(4)

숫자 4가 나오는데 이것은 실행 결과로 4개의 행이 있다는 것을 의미한다.
만약 데이터가 5개였다면 숫자 5가 출력될 것이다.
mysqli_result는 이런 속성으로 구성되고 이것들이 나중에 필요할 수 있다.
개발자들은 단서를 모아서 자신의 문제를 차근차근 해결해 나간다는 사례를 이번 시간에 보여주고 싶었다.
이렇게 해서 mysqli_query()를 통해 select문을 데이터 베이스에 전송하는 법을 살펴봤고 실제로 데이터를 끌고 오는 것까지는 못했다.
이어지는 주제에 다루겠다.

*SELECT 사용법 2

이전 시간에 select 문을 데이터베이스에 전송하는 법까지 살펴봤다.
이제부터 가져온 데이터를 PHP에서 활용할 수 있어야 한다.
그런데 데이터베이스와 PHP는 완전히 다른 기술이기 때문에 PHP라는 컴퓨터 언어를 통해 데이터를 활용하려면 PHP의 데이터 타입으로 전환하는 과정을 거쳐야 한다.
이를 위한 API가 바로 mysqli_fetch_XXX라는 이름의 API다.
여기서 fetch는 가져오다라는 뜻이다.
즉, mysqli_query를 통해 가져온 데이터들을 PHP에서 사용할 수 있게 전환해서 가져온다는 것이다.
이때 여러분이 선호하는 데이터 타입(예: 배열, 연관배열, 객체)을 지정할 수 있다.
그중에서 아직까진 배열이 익숙하니 mysqli_fetch_array()를 검색해서 찾아보겠다.

https://www.php.net/manual/en/mysqli-result.fetch-array.php 참고

실행 결과 )

Array (
 [0] => 17
 [index] => 17
 [1] => MySQL
 [title] => MySQL
 [2] => MySQL is...
 [description] => MySQL is...
 [3] => 2020-11-22 01:42:43
 [created] => 2020-11-22 01:42:43 
)

이를 통해 알 수 있는 것은 mysql_fetch_array()를 실행했더니 첫 번째로는 배열이 반환됐다는 것, 두번째로는 실제 데이터베이스에는 4건의 데이터가 저장돼 있는데 4개의 데이터 중 첫 번째 행만이 들어간 것을 확인 할 수 있다.
그리고 출력된 값을 보면 값들이 두 번씩 반복된다.
값이 두 번 반복되는데 첫 번째로는 그 값의 자릿수가 나오고 두번째로는 칼럼명이 나온다.
즉 이를 통해 데이터를 선택적으로 가져올 수 있다. 여기서는 이것을 $row라는 변수에 담겠다.


<?php
    $conn = mysqli_connect('127.0.0.1','somej','sns5sms!','mydb');

    $sql = " SELECT * FROM topic ";

    $result = mysqli_query($conn,$sql);

    $row = print_r(mysqli_fetch_array($result));//print_r : php변수 정보 출력(배열포함)

    // echo var_dump($result->num_rows)."<br>";
?>

따라서 $row라는 변수를 대상으로 $row[0]을 확인해 보면 index가 나올 것이다.
$row[1]을 확인해보면 MySQL이 나오게 된다, 1대신 title을 써도 결과는 같다.
즉 결과의 자릿수를 이용해 데이터를 가져올 수도 있고, 칼럼의 이름을 이용해 데이터를 가져올 수도 있다.
이처럼 칼럼의 이름을 통해 가져오는 형식의 배열을 연관배열이라고 한다.
그리고 숫자를 통해 자릿수, 즉 인덱스를 통해 가져오는 형태는 배열이라고 한다.
이 맥락에서는 어떤 게 더 좋은가?
연관배열이 훨씬 좋다.
왜냐하면 자릿수는 몰라도 칼럼의 이름으로 사용할 수 있기 때문이다.

이 사실만을 이용해서 알 수 있는 것은 모든 topic의 데이터가 아니라 딱 하나의 행만 가져오고 싶다면 다음과 같이 SQL문을 작성해서 값을 가져올 수 있다는 것이다.


<?php
    $conn = mysqli_connect('127.0.0.1','somej','sns5sms!','mydb');

    echo "<h1>Single row</h1>";
    $sql = " SELECT * FROM topic WHERE id='21' ";

    $result = mysqli_query($conn,$sql);
    if($result == false){
        echo "<script>alert('문제가 생겼습니다')</script>";
        error_log($conn);
    }

    // $row = print_r(mysqli_fetch_array($result));//print_r : php변수 정보 출력(배열포함)

    $row = mysqli_fetch_array($result);//print_r : php변수 정보 출력(배열포함)

    // echo var_dump($result->num_rows)."<br>";

    echo '<h2>'.$row['title'].'</h2>';
    echo $row['description'];

?>

echo '<h1>'.$row['title'].'</h1>';과 같이 이름을 사용하도록 코드를 작성해서 프로그램을 실행하면 결과는 '<h1>Mysql</h1>'이 되고 echo '$row['description'];'과 같이 작성하고 프로그램을 실행하면 결과는 테스트입니다.가 나온다.
이처럼 하나의 행을 표현할 수 있게 되는 것이다.

그럼 행이 여러 개인 경우에는 어떻게 하는지 자연스럽게 궁금해질것이다.

*SELECT 사용법 3

다음 SQL 문은 row가 하나일 때 이다.
이번에는 전체 row를 가져오는 경루를 살펴보겠다.

$sql = "SELECT * FROM topic WHERE id='21';

위 SQL 문에서 뒤에 붙은 where문을 지워보겠다.
mysql_fetch_array()의 또 다른 특징은 이것을 실행할 때마다 $result가 가리키는 쿼리문의 결과를 하나씩 배열로 반환한다는 것이다.
그래서 2개를 반복해서 써보겠다.

<?php
    $conn = mysqli_connect('127.0.0.1','somej','sns5sms!','mydb');

    echo "<h1>Single row</h1>";
    $sql = " SELECT * FROM topic";

    $result = mysqli_query($conn,$sql);
    if($result == false){
        echo "<script>alert('문제가 생겼습니다')</script>";
        error_log($conn);
    }

    // $row = print_r(mysqli_fetch_array($result));//print_r : php변수 정보 출력(배열포함)

    $row = mysqli_fetch_array($result);//print_r : php변수 정보 출력(배열포함)

    // echo var_dump($result->num_rows)."<br>";

    echo '<h2>'.$row['title'].'</h2>';
    echo $row['description'];

    $row = mysqli_fetch_array($result);
    echo '<h2>'.$row['title'].'</h2>';
    echo $row['description'];
    
?>

첫 번째로 실행될 때 'MySQL'[첫 번째 row]이 나오고, 두 번째로 실행될 때 'Javascript'[두 번째 row]가 나온다.
즉, Javascript는 두 번째 행이였다.
프로그램을 또 한번 실행하면 이번에는 세 번째 행이 나오고,...[반복된다]

그럼 이번에는 더 이상 가져올 데이터가 없을 때 mysqli_fetch_array()가 어떻게 하는 살펴보겠다.

코드)
$row = mysqli_fetch_array($result);//print_r : php변수 정보 출력(배열포함)

    // echo var_dump($result->num_rows)."<br>";

    echo '<h2>'.$row['title'].'</h2>';
    echo $row['description'];

    $row = mysqli_fetch_array($result);
    echo '<h2>'.$row['title'].'</h2>';
    echo $row['description'];
    
    $row = mysqli_fetch_array($result);
    echo '<h2>'.$row['title'].'</h2>';
    echo $row['description'];

    $row = mysqli_fetch_array($result);
    echo '<h2>'.$row['title'].'</h2>';
    echo $row['description'];

    $row = mysqli_fetch_array($result);
    echo '<h2>'.$row['title'].'</h2>';
    echo $row['description'];
    
    $row = mysqli_fetch_array($result);
    echo '<h2>'.$row['title'].'</h2>';
    echo $row['description'];

실행 결과)

Single row
MySQL
MySQL is...
JavaScript
JavaScript is...
HTML
HTML is....
CSS
CSS is....
테스트
테스트입니다

더 이상 가져올 데이터가 없으면 아무것도 나오지 않는다.

그럼 더 이상 가져올 수 없을 때 $row라는 변수에는 무엇이 담겨있는지 구체적으로 살펴보겠다.

결과)

null

보다시피 null 값이 나온다.
이런 경험을 종합했을 때 다음과 같이 추론할 수 있다.
'mysql_fetch_array()라는 함수는 실행할 때마다 한 행씩 주는구나, 더 이상 줄 수 없다면 null 을 주는구나' 라고 추론할 수 있고 이를 이론적으로 정리하기 위해 메뉴얼로 가서 'Return Values'라는 부분을 보면 만약 가져올 수 있는 행이 없으면 null 을 준다는 것을 알 수 있다.

https://www.php.net/manual/en/mysqli-result.fetch-array.php 참조

그럼 이 상태에서 데이터를 삭제했다면 더 이상 호출할 필요가 없는 코드가 존재할 것이고, 데이터가 추가돼서 5개라면 데이터를 추가했음에도 출력하지 않는다.
이런 상황에서 프로그래머들이 수치스러워하는 것은 데이터가 바뀌었다고 로직을 바꾸는 것이다.
이런 상황이라면 코드를 추가하거나 없애야 한다.
그런데 잘 보면 어떤 일을 하고 있나요?
반복적인 일을 하고 있다.
따라서 반복문을 사용하면 된다.
반복문을 사용하기 위해 필요한 몇가지 복잡한 이야기가 있으니 몇가지 알고 있어야 할 만한 사항들을 설명하겠다.

(나머지 생략.. while문 참고..)

var_dump(null == false);

==는 비교 연산자이고 왼쪽의 null과 오른쪽의  flase가 같다면 참이 되는데 결과가 true라는 것은 php에서는 null 값을 false라고 친다는 뜻이다.

이렇게 해서 우리가 하려는 일들을 위한 부품을 다 모았다.
select.php로 가서 반복했던 코드들을 지우고 반복문으로 바꿔보겠다.

예)

while($row = mysqli_fetch_array($result)){
        echo '<h2>'.$row['title'].'</h2>';
        echo $row['description'];
    };

결과)

Single row
MySQL
MySQL is...
JavaScript
JavaScript is...
HTML
HTML is....
CSS
CSS is....
테스트
테스트입니다

보다시피 프로그램을 실행하면 모든 행을 다 가져온다.
먼저 php는 mysqli_fetch_array($result)를 실행해 첫 번째 행을 가져온다.
그 값을 $row에 담는다.
$row=mysqli_fetch_array($result)의 값은 그 값 자체가 되는 것이다.
그런데 php에서는 어떠한 값이 false거나 null 이 아니라면 그것을 참으로 친다.
그런 참이 되는 것이고 중괄호 안의 코드가 실행되고 더 이상 실행할 것이 없다면 이번에는 두 번째 행을 $row에 담고 true가 되며 다음 행이 실행된다.
이런식으로 반복하다 더 이상 가져올 데이터가 없으면 mysqli_fetch_array()는 null을 반환하는데 php는 null을 false로 평가하면서 반복문이 끝나고 모든 작업이 끝나게 된다.

이 부분은 복잡해서 한 번에 이해하기에는 어렵다.
따라서 코드와 설명을 한 번 더 보거나 다음 시간에 select문을 활용해 예제 애플리케이션에 적용하는 것을 해볼 테니 그때 다시 한 번 리뷰해 봐도 된다.

*활용 - 글 읽기1

지금까지 select 문을 mysqli API를 통해 서버에 전달하고 그 결과를 받아와서 출력하는 방법을 살펴봤는데 이제 실전에 적용해 보도록 하겠다.
예제 애플리케이션에 이를 반영해서 데이터 베이스의 내용을 반영한 결과를 합성해 보자.

우선 index.php 파일을 연 다음 글 목록부터 본문까지 처리하겠다.
우선 데이터베이스에서 데이터를 가져와야 하므로 select.php에 들어있는 데이터베이스 접속용 코드를 index.php 상단에 붙여넣는다.

$conn = mysqli_connect('127.0.0.1','somej','sns5sms!','mydb');

그 다음 글 목록에 있는 모든 항목을 가져오면 된다.

 $sql = " SELECT * FROM topic";
$result = mysqli_query($conn,$sql);

while($row = mysqli_fetch_array($result)){
        echo '<li>{$row['title']}</li>'; // "<li>".$row['title']."</li>" == "<li>{$row['title']}</li>" 같은 말

SQL 문을 데이터베이스 서버에 전송하는 API는 mysqli_query()이며 첫 번째 인자로는 데이터베이스 접속 식별자가 들어가고, 그 다음에는 SQL문이 들어간다.
그렇게 만들어진 결과를 $result에 담았고, 이 결과를 글 목록에 적용해 봤다.
그런 다음 mysqli_fetch_array($result)의 결과를 $row라는 변수에 담을 것이고 이 함수를 실행할 때마다 한 행씩 보여주기 때문에 반복적으로 실행해야 한다.
그리고 가져올 것이 없을때 null이 된다는 특성이 있었으므로 while문을 쓴다.
마지막으로 echo "<li>{$row['title']}</li>"로 글 목록을 출력한 뒤 결과를 확인해보자

결과 )

WEB
MySQL
JavaScript
HTML
CSS
테스트

그런데 데이터 베이스를 제어하는 코드와 표현과 관련된 코드가 엉켜있으니 보기가 안 좋은 것 같다.
위로 코드를 옮기고 $list의 경우 기존의 $list와 결합해서 다음과 같은 코드로 수정한다.

<?php
        $conn = mysqli_connect('127.0.0.1','somej','sns5sms!','mydb');

        $sql = "SELECT * FROM topic";

        $result = mysqli_query($conn,$sql);
        if($result == false){
            echo "<script>alert('오류가 생겼습니다.')</script>";
        };
        $list = '';//변수 초기화

        while($row = mysqli_fetch_array($result)){
            $list = $list."<li>{$row['title']}</li>";
        }
    ?>
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PHP와 MYSQL서버 연동</title>
</head>
<body>
    <h1>WEB</h1>
    <ol>
        <?=$list?>
    </ol>
    <a href="create.php">create</a>
    <a href="select.php">목록</a>
    <h2>Welcome</h2>
    Lorem ipsum dolor sit amet, consectertur adipisicing elit,
</body>
</html>

결과적으로는 글 목록이 나올 곳에 echo $list;만 적으면 복잡한 PHP 코드는 글 목록 부분에서 최소화되고 PHP는 PHP끼리, HTML은 HTML끼리 응집되는 효과가 있다.
여기서 <?=$list?>는 <?php echo $list ?> 와 같다.
결과는 같지만 코드는 조금 더 간결해 졌다.

그 다음으로 할 작업은 <li>에 링크를 거는 것인데 본인이 하고 싶은 것은 다음과 같이 만드는 것이다.

<li><a href="index.php?id=5">Mysql</li>

즉, 위와 같은 코드가 프로그래밍 적으로 생성되게 하고 싶은 것이다.
따라서 다음과 같이 작성한다.

<?php
        $conn = mysqli_connect('127.0.0.1','somej','sns5sms!','mydb');

        $sql = "SELECT * FROM topic";

        $result = mysqli_query($conn,$sql);
        if($result == false){
            echo "<script>alert('오류가 생겼습니다.')</script>";
        };
        $list = '';//변수 초기화

        while($row = mysqli_fetch_array($result)){
            $list = $list."<li><a href=\"index.php?id={$row['id']}\">{$row['title']}</a></li>";
        }
    ?>
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PHP와 MYSQL서버 연동</title>
</head>
<body>
    <h1>WEB</h1>
    <ol>
        <?=$list?>
    </ol>
    <a href="create.php">create</a>
    <a href="select.php">목록</a>
    <h2>Welcome</h2>
    Lorem ipsum dolor sit amet, consectertur adipisicing elit,
</body>
</html>

list목록을 눌러보면 해당 id가 잘뜨는 것을 확인할 수 있다.


*활용 글 읽기 2

이번에는 각 id 값에 해당하는, 즉 선택한 글에 해당하는 본문을 출력하는 코드를 만들어 보자.
이를 위해 index.php 상단에 다음과 같은 코드를 추가한다.

$sql = "SELECT * FROM topic WHERE id={$_GET['id']}"

id 값이 바뀜에 따라 SQL문이 자동으로 생성된다. 이를 MySQL서버로 전송해야 한다.

 $sql = "SELECT * FROM topic WHERE id={$_GET['id']}"; // id 값이 바뀜에 따라 SQL문이 자동으로 생성된다. 이를 MySQL서버로 전송해야 한다.
        $result = mysqli_query($conn,$sql);
        $row = mysqli_fetch_array($result);
        $article = array(
            'title' => $row['title'],
            'description' => $row['description']
        );
        print_r($article);

mysqli_query()를 이용해 그 결과를 $result에 담는다.
그리고 $result를 배열로 만들고 싶다.

mysqli_fetch_array()를 이용해 $row에 담는다.
여기서는 특정 id, 즉 단 하나의 행만 가져오기 때문에 반복문을 쓸 필요가 없다.
그렇게 가져온 정보를 $article이라는 변수에 담는다.
이 변수는 배열인데 배열의 값으로 title 에는 $row['title']을, description에는 $row['description']을 담는다. 이를 출력해보자

결과)
Array ( [title] => 테스트 [description] => 테스트입니다 )


위와 같이 하면 배열이 잘 들어 있느 모습을 볼 수 있다.
앞서 키 값이 문자인 배열을 연관배열이라 부른다고 설명했다.
그리고 $article 변수를 이용해 제목을 표시하는 부분에 <?=$article['title']?>을, 본문을 표시하는 부분에 <?=$article['description']?>와 같이 작성한다.

<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PHP와 MYSQL서버 연동</title>
</head>
<body>
    <h1>WEB</h1>
    <ol>
        <?=$list?>
    </ol>
    <a href="create.php">create</a>
    <a href="select.php">목록</a>
    <h2><?=$article['title']?></h2>//이부분은 <?php echo="{$article['title']}"?>이부분과 동일하다.
    <p><?=$article['description']?></p>
</body>
</html>

페이지를 새로고침했을 때 id 값이 없으면 여러 군데에서 에러가 생긴다.

Notice: Undefined index: id in C:\AutoSet10\public_html\practice\phpmysql\index.php on line 16

Warning: mysqli_fetch_array() expects parameter 1 to be mysqli_result, boolean given in C:\AutoSet10\public_html\practice\phpmysql\index.php on line 18
Array ( [title] => [description] => )

그러면 조건문을 통해 id값이 존재하느냐에 따라 이전 코드를 감싸면 된다.

 if(isset($_GET['id'])){
        $sql = "SELECT * FROM topic WHERE id={$_GET['id']}"; // id 값이 바뀜에 따라 SQL문이 자동으로 생성된다. 이를 MySQL서버로 전송해야 한다.
        $result = mysqli_query($conn,$sql);
        $row = mysqli_fetch_array($result);
        $article = array(//배열로 만들어 $article 변수에 저장한다.
            'title' => $row['title'], //key => value
            'description' => $row['description']
        );
        }


글 목록에서는 에러가 발생하지 않았지만 $article 부분에 에러가 나타난다.
그래서 $article을 이용해 title에는 'welcome을, description에는 'hello, web'이라는 기본적인 내용을 적고 그 아래는 다음과 같이 수정한다.


$article = array(//id 값이 없을때는 key와 value값을 직접 넣어 설정해준다.
            'title'=>'welcome',
            'description'=>'hello, web'
        );

        if(isset($_GET['id'])){
        $sql = "SELECT * FROM topic WHERE id={$_GET['id']}"; // id 값이 바뀜에 따라 SQL문이 자동으로 생성된다. 이를 MySQL서버로 전송해야 한다.
        $result = mysqli_query($conn,$sql);
        $row = mysqli_fetch_array($result);
        $article['title'] = $row['title'];
        $article['description'] = $row['description'];

결과를 보면 잘 출력되는 것을 볼 수 있다.
index.php에서 <ol> 태그부터 위쪽까지 전체를 복사해서 create.php에 붙여넣으면 create.php에도 전체적으로 적용되는 모습을 볼 수 있다.
